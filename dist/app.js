/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/server/app.tsx");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/koa-swig/index.js":
/*!*****************************************!*\
  !*** ../node_modules/koa-swig/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*!\n * swig\n * Copyright(c) 2015 Fangdun Cai\n * MIT Licensed\n */\n\n\n\n/**\n * Module dependences.\n */\n\nconst debug = __webpack_require__(/*! debug */ \"debug\")('koa:swig');\nconst mixin = __webpack_require__(/*! utils-merge */ \"../node_modules/utils-merge/index.js\");\nconst thenify = __webpack_require__(/*! thenify */ \"thenify\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst swig = __webpack_require__(/*! swig-templates */ \"../node_modules/swig-templates/index.js\");\nconst extname = path.extname;\nconst resolve = path.resolve;\n\n/**\n * Expose `render`, `swig`.\n */\n\nexports = module.exports = renderer;\nexports.swig = swig;\n\n/**\n * Default render settings.\n */\n\nconst defaultSettings = {\n  autoescape: true,\n  root: 'views',\n  cache: 'memory',\n  ext: 'html',\n  writeBody: true\n    /*\n    locals: {},\n    filters: {}.\n    tags: {},\n    extensions: {}\n    */\n};\n\n// Generator `renderFile`\n\nconst renderFile = thenify(swig.renderFile);\n\nfunction renderer(settings) {\n  // merge default settings\n  var sets = Object.create(defaultSettings);\n\n  // merge settings\n  if (settings) {\n    mixin(sets, settings);\n  }\n  settings = sets;\n\n  var root = settings.root;\n  var locals = settings.locals || {};\n  var cache = settings.cache;\n  var defaults = {\n    autoescape: settings.autoescape,\n    cache: cache,\n    locals: locals\n  };\n  if (settings.varControls) {\n    defaults.varControls = settings.varControls;\n  }\n  if (settings.tagControls) {\n    defaults.tagControls = settings.tagControls;\n  }\n  if (settings.cmtControls) {\n    defaults.cmtControls = settings.cmtControls;\n  }\n  swig.setDefaults(defaults);\n\n  // swig custom filters\n  setFilters(swig, settings.filters);\n\n  // swig custom tags\n  setTags(swig, settings.tags);\n\n  // add extensions for custom tags\n  setExtensions(swig, settings.extensions);\n\n  swig.setLocals = setLocals;\n\n  swig.getLocals = getLocals;\n\n  return render;\n\n  function* render(view, options) {\n    // default extname\n    var e = extname(view);\n\n    if (!e) {\n      e = '.' + settings.ext;\n      view += e;\n    }\n\n    // resolve\n    view = resolve(root, view);\n\n    // merge ctx.state\n    var opts = this.state || {};\n\n    // merge ctx.flash, for `koa-flash` or `koa-connect-flash`\n    mixin(opts, {\n      flash: this.flash,\n      cache: cache\n    });\n\n    // merge settings.locals\n    mixin(opts, locals);\n\n    // merge options\n    mixin(opts, options || {});\n\n    debug('render %s %j', view, opts);\n    var html = yield renderFile(view, opts);\n    /* jshint validthis:true */\n\n    if (settings.writeBody === true) {\n      this.body = html;\n    }\n\n    return html;\n  }\n\n  function setLocals(args) {\n    mixin(locals,args);\n  }\n\n  function getLocals(key) {\n    return locals[key];\n  }\n\n}\n\n/**\n * Add filters for Swig\n */\n\nfunction setFilters(swig, filters) {\n  for (var name in filters) {\n    swig.setFilter(name, filters[name]);\n  }\n}\n\n/**\n * Add tags for Swig\n */\n\nfunction setTags(swig, tags) {\n  var name, tag;\n  for (name in tags) {\n    tag = tags[name];\n    swig.setTag(name, tag.parse, tag.compile, tag.ends, tag.blockLevel);\n  }\n}\n\n/**\n * Add extensions for Swig\n */\n\nfunction setExtensions(swig, extensions) {\n  for (var name in extensions) {\n    swig.setExtension(name, extensions[name]);\n  }\n\n\n}\n\n\n//# sourceURL=webpack:///../node_modules/koa-swig/index.js?");

/***/ }),

/***/ "../node_modules/swig-templates/index.js":
/*!***********************************************!*\
  !*** ../node_modules/swig-templates/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/swig */ \"../node_modules/swig-templates/lib/swig.js\")\n\n\n//# sourceURL=webpack:///../node_modules/swig-templates/index.js?");

/***/ }),

/***/ "../node_modules/swig-templates/lib/dateformatter.js":
/*!***********************************************************!*\
  !*** ../node_modules/swig-templates/lib/dateformatter.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var utils = __webpack_require__(/*! ./utils */ \"../node_modules/swig-templates/lib/utils.js\")\n\nvar _months = {\n  full: [\n    'January',\n    'February',\n    'March',\n    'April',\n    'May',\n    'June',\n    'July',\n    'August',\n    'September',\n    'October',\n    'November',\n    'December'\n  ],\n  abbr: [\n    'Jan',\n    'Feb',\n    'Mar',\n    'Apr',\n    'May',\n    'Jun',\n    'Jul',\n    'Aug',\n    'Sep',\n    'Oct',\n    'Nov',\n    'Dec'\n  ]\n}\nvar _days = {\n  full: [\n    'Sunday',\n    'Monday',\n    'Tuesday',\n    'Wednesday',\n    'Thursday',\n    'Friday',\n    'Saturday'\n  ],\n  abbr: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n  alt: { '-1': 'Yesterday', 0: 'Today', 1: 'Tomorrow' }\n}\n\n/*\nDateZ is licensed under the MIT License:\nCopyright (c) 2011 Tomo Universalis (http://tomouniversalis.com)\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\nexports.tzOffset = 0\nexports.DateZ = function () {\n  var members = {\n    default: [\n      'getUTCDate',\n      'getUTCDay',\n      'getUTCFullYear',\n      'getUTCHours',\n      'getUTCMilliseconds',\n      'getUTCMinutes',\n      'getUTCMonth',\n      'getUTCSeconds',\n      'toISOString',\n      'toGMTString',\n      'toUTCString',\n      'valueOf',\n      'getTime'\n    ],\n    z: [\n      'getDate',\n      'getDay',\n      'getFullYear',\n      'getHours',\n      'getMilliseconds',\n      'getMinutes',\n      'getMonth',\n      'getSeconds',\n      'getYear',\n      'toDateString',\n      'toLocaleDateString',\n      'toLocaleTimeString'\n    ]\n  }\n  var d = this\n\n  d.date = d.dateZ =\n    arguments.length > 1\n      ? new Date(\n        Date.UTC.apply(Date, arguments) +\n            new Date().getTimezoneOffset() * 60000\n      )\n      : arguments.length === 1 ? new Date(new Date(arguments['0'])) : new Date()\n\n  d.timezoneOffset = d.dateZ.getTimezoneOffset()\n\n  utils.each(members.z, function (name) {\n    d[name] = function () {\n      return d.dateZ[name]()\n    }\n  })\n  utils.each(members['default'], function (name) {\n    d[name] = function () {\n      return d.date[name]()\n    }\n  })\n\n  this.setTimezoneOffset(exports.tzOffset)\n}\nexports.DateZ.prototype = {\n  getTimezoneOffset: function () {\n    return this.timezoneOffset\n  },\n  setTimezoneOffset: function (offset) {\n    this.timezoneOffset = offset\n    this.dateZ = new Date(\n      this.date.getTime() +\n        this.date.getTimezoneOffset() * 60000 -\n        this.timezoneOffset * 60000\n    )\n    return this\n  }\n}\n\n// Day\nexports.d = function (input) {\n  return (input.getDate() < 10 ? '0' : '') + input.getDate()\n}\nexports.D = function (input) {\n  return _days.abbr[input.getDay()]\n}\nexports.j = function (input) {\n  return input.getDate()\n}\nexports.l = function (input) {\n  return _days.full[input.getDay()]\n}\nexports.N = function (input) {\n  var d = input.getDay()\n  return d >= 1 ? d : 7\n}\nexports.S = function (input) {\n  var d = input.getDate()\n  return d % 10 === 1 && d !== 11\n    ? 'st'\n    : d % 10 === 2 && d !== 12 ? 'nd' : d % 10 === 3 && d !== 13 ? 'rd' : 'th'\n}\nexports.w = function (input) {\n  return input.getDay()\n}\nexports.z = function (input, offset, abbr) {\n  var year = input.getFullYear()\n  var e = new exports.DateZ(year, input.getMonth(), input.getDate(), 12, 0, 0)\n  var d = new exports.DateZ(year, 0, 1, 12, 0, 0)\n\n  e.setTimezoneOffset(offset, abbr)\n  d.setTimezoneOffset(offset, abbr)\n  return Math.round((e - d) / 86400000)\n}\n\n// Week\nexports.W = function (input) {\n  var target = new Date(input.valueOf())\n  var dayNr = (input.getDay() + 6) % 7\n  var fThurs\n\n  target.setDate(target.getDate() - dayNr + 3)\n  fThurs = target.valueOf()\n  target.setMonth(0, 1)\n  if (target.getDay() !== 4) {\n    target.setMonth(0, 1 + (4 - target.getDay() + 7) % 7)\n  }\n\n  return 1 + Math.ceil((fThurs - target) / 604800000)\n}\n\n// Month\nexports.F = function (input) {\n  return _months.full[input.getMonth()]\n}\nexports.m = function (input) {\n  return (input.getMonth() < 9 ? '0' : '') + (input.getMonth() + 1)\n}\nexports.M = function (input) {\n  return _months.abbr[input.getMonth()]\n}\nexports.n = function (input) {\n  return input.getMonth() + 1\n}\nexports.t = function (input) {\n  return 32 - new Date(input.getFullYear(), input.getMonth(), 32).getDate()\n}\n\n// Year\nexports.L = function (input) {\n  return new Date(input.getFullYear(), 1, 29).getDate() === 29\n}\nexports.o = function (input) {\n  var target = new Date(input.valueOf())\n  target.setDate(target.getDate() - (input.getDay() + 6) % 7 + 3)\n  return target.getFullYear()\n}\nexports.Y = function (input) {\n  return input.getFullYear()\n}\nexports.y = function (input) {\n  return input\n    .getFullYear()\n    .toString()\n    .substr(2)\n}\n\n// Time\nexports.a = function (input) {\n  return input.getHours() < 12 ? 'am' : 'pm'\n}\nexports.A = function (input) {\n  return input.getHours() < 12 ? 'AM' : 'PM'\n}\nexports.B = function (input) {\n  var hours = input.getUTCHours()\n  var beats\n  hours = hours === 23 ? 0 : hours + 1\n  beats = Math.abs(\n    ((hours * 60 + input.getUTCMinutes()) * 60 + input.getUTCSeconds()) / 86.4\n  ).toFixed(0)\n  return '000'.concat(beats).slice(beats.length)\n}\nexports.g = function (input) {\n  var h = input.getHours()\n  return h === 0 ? 12 : h > 12 ? h - 12 : h\n}\nexports.G = function (input) {\n  return input.getHours()\n}\nexports.h = function (input) {\n  var h = input.getHours()\n  return (h < 10 || (h > 12 && h < 22) ? '0' : '') + (h < 12 ? h : h - 12)\n}\nexports.H = function (input) {\n  var h = input.getHours()\n  return (h < 10 ? '0' : '') + h\n}\nexports.i = function (input) {\n  var m = input.getMinutes()\n  return (m < 10 ? '0' : '') + m\n}\nexports.s = function (input) {\n  var s = input.getSeconds()\n  return (s < 10 ? '0' : '') + s\n}\n// u = function () { return ''; },\n\n// Timezone\n// e = function () { return ''; },\n// I = function () { return ''; },\nexports.O = function (input) {\n  var tz = input.getTimezoneOffset()\n  return (\n    (tz < 0 ? '-' : '+') + (tz / 60 < 10 ? '0' : '') + Math.abs(tz / 60) + '00'\n  )\n}\n// T = function () { return ''; },\nexports.Z = function (input) {\n  return input.getTimezoneOffset() * 60\n}\n\n// Full Date/Time\nexports.c = function (input) {\n  return input.toISOString()\n}\nexports.r = function (input) {\n  return input.toUTCString()\n}\nexports.U = function (input) {\n  return input.getTime() / 1000\n}\n\n\n//# sourceURL=webpack:///../node_modules/swig-templates/lib/dateformatter.js?");

/***/ }),

/***/ "../node_modules/swig-templates/lib/filters.js":
/*!*****************************************************!*\
  !*** ../node_modules/swig-templates/lib/filters.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var utils = __webpack_require__(/*! ./utils */ \"../node_modules/swig-templates/lib/utils.js\")\nvar dateFormatter = __webpack_require__(/*! ./dateformatter */ \"../node_modules/swig-templates/lib/dateformatter.js\")\n\n/**\n * Helper method to recursively run a filter across an object/array and apply it to all of the object/array's values.\n * @param  {*} input\n * @return {*}\n * @private\n */\nfunction iterateFilter (input) {\n  var self = this\n  var out = {}\n\n  if (utils.isArray(input)) {\n    return utils.map(input, function (value) {\n      return self.apply(null, arguments)\n    })\n  }\n\n  if (typeof input === 'object') {\n    utils.each(input, function (value, key) {\n      out[key] = self.apply(null, arguments)\n    })\n    return out\n  }\n}\n\n/**\n * Backslash-escape characters that need to be escaped.\n *\n * @example\n * {{ \"\\\"quoted string\\\"\"|addslashes }}\n * // => \\\"quoted string\\\"\n *\n * @param  {*}  input\n * @return {*}        Backslash-escaped string.\n */\nexports.addslashes = function (input) {\n  var out = iterateFilter.apply(exports.addslashes, arguments)\n  if (out !== undefined) {\n    return out\n  }\n\n  return input\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/'/g, \"\\\\'\")\n    .replace(/\"/g, '\\\\\"')\n}\n\n/**\n * Upper-case the first letter of the input and lower-case the rest.\n *\n * @example\n * {{ \"i like Burritos\"|capitalize }}\n * // => I like burritos\n *\n * @param  {*} input  If given an array or object, each string member will be run through the filter individually.\n * @return {*}        Returns the same type as the input.\n */\nexports.capitalize = function (input) {\n  var out = iterateFilter.apply(exports.capitalize, arguments)\n  if (out !== undefined) {\n    return out\n  }\n\n  return (\n    input\n      .toString()\n      .charAt(0)\n      .toUpperCase() +\n    input\n      .toString()\n      .substr(1)\n      .toLowerCase()\n  )\n}\n\n/**\n * Format a date or Date-compatible string.\n *\n * @example\n * // now = new Date();\n * {{ now|date('Y-m-d') }}\n * // => 2013-08-14\n * @example\n * // now = new Date();\n * {{ now|date('jS \\o\\f F') }}\n * // => 4th of July\n *\n * @param  {?(string|date)}   input\n * @param  {string}           format  PHP-style date format compatible string. Escape characters with <code>\\</code> for string literals.\n * @param  {number=}          offset  Timezone offset from GMT in minutes.\n * @param  {string=}          abbr    Timezone abbreviation. Used for output only.\n * @return {string}                   Formatted date string.\n */\nexports.date = function (input, format, offset, abbr) {\n  var l = format.length\n  var date = new dateFormatter.DateZ(input)\n  var cur\n  var i = 0\n  var out = ''\n\n  if (offset) {\n    date.setTimezoneOffset(offset, abbr)\n  }\n\n  for (i; i < l; i += 1) {\n    cur = format.charAt(i)\n    if (cur === '\\\\') {\n      i += 1\n      out += i < l ? format.charAt(i) : cur\n    } else if (dateFormatter.hasOwnProperty(cur)) {\n      out += dateFormatter[cur](date, offset, abbr)\n    } else {\n      out += cur\n    }\n  }\n  return out\n}\n\n/**\n * If the input is `undefined`, `null`, or `false`, a default return value can be specified.\n *\n * @example\n * {{ null_value|default('Tacos') }}\n * // => Tacos\n *\n * @example\n * {{ \"Burritos\"|default(\"Tacos\") }}\n * // => Burritos\n *\n * @param  {*}  input\n * @param  {*}  def     Value to return if `input` is `undefined`, `null`, or `false`.\n * @return {*}          `input` or `def` value.\n */\nexports['default'] = function (input, def) {\n  return input !== undefined && (input || typeof input === 'number')\n    ? input\n    : def\n}\n\n/**\n * Force escape the output of the variable. Optionally use `e` as a shortcut filter name. This filter will be applied by default if autoescape is turned on.\n *\n * @example\n * {{ \"<blah>\"|escape }}\n * // => &lt;blah&gt;\n *\n * @example\n * {{ \"<blah>\"|e(\"js\") }}\n * // => \\u003Cblah\\u003E\n *\n * @param  {*} input\n * @param  {string} [type='html']   If you pass the string js in as the type, output will be escaped so that it is safe for JavaScript execution.\n * @return {string}         Escaped string.\n */\nexports.escape = function (input, type) {\n  var out = iterateFilter.apply(exports.escape, arguments)\n  var inp = input\n  var i = 0\n  var code\n\n  if (out !== undefined) {\n    return out\n  }\n\n  if (typeof input !== 'string') {\n    return input\n  }\n\n  out = ''\n\n  switch (type) {\n    case 'js':\n      inp = inp.replace(/\\\\/g, '\\\\u005C')\n      for (i; i < inp.length; i += 1) {\n        code = inp.charCodeAt(i)\n        if (code < 32) {\n          code = code.toString(16).toUpperCase()\n          code = code.length < 2 ? '0' + code : code\n          out += '\\\\u00' + code\n        } else {\n          out += inp[i]\n        }\n      }\n      return out\n        .replace(/&/g, '\\\\u0026')\n        .replace(/</g, '\\\\u003C')\n        .replace(/>/g, '\\\\u003E')\n        .replace(/'/g, '\\\\u0027')\n        .replace(/\"/g, '\\\\u0022')\n        .replace(/=/g, '\\\\u003D')\n        .replace(/-/g, '\\\\u002D')\n        .replace(/;/g, '\\\\u003B')\n\n    default:\n      return inp\n        .replace(/&(?!amp;|lt;|gt;|quot;|#39;)/g, '&amp;')\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n        .replace(/\"/g, '&quot;')\n        .replace(/'/g, '&#39;')\n  }\n}\nexports.e = exports.escape\n\n/**\n * Get the first item in an array or character in a string. All other objects will attempt to return the first value available.\n *\n * @example\n * // my_arr = ['a', 'b', 'c']\n * {{ my_arr|first }}\n * // => a\n *\n * @example\n * // my_val = 'Tacos'\n * {{ my_val|first }}\n * // T\n *\n * @param  {*} input\n * @return {*}        The first item of the array or first character of the string input.\n */\nexports.first = function (input) {\n  if (typeof input === 'object' && !utils.isArray(input)) {\n    var keys = utils.keys(input)\n    return input[keys[0]]\n  }\n\n  if (typeof input === 'string') {\n    return input.substr(0, 1)\n  }\n\n  return input[0]\n}\n\n/**\n * Group an array of objects by a common key. If an array is not provided, the input value will be returned untouched.\n *\n * @example\n * // people = [{ age: 23, name: 'Paul' }, { age: 26, name: 'Jane' }, { age: 23, name: 'Jim' }];\n * {% for agegroup in people|groupBy('age') %}\n *   <h2>{{ loop.key }}</h2>\n *   <ul>\n *     {% for person in agegroup %}\n *     <li>{{ person.name }}</li>\n *     {% endfor %}\n *   </ul>\n * {% endfor %}\n *\n * @param  {*}      input Input object.\n * @param  {string} key   Key to group by.\n * @return {object}       Grouped arrays by given key.\n */\nexports.groupBy = function (input, key) {\n  if (!utils.isArray(input)) {\n    return input\n  }\n\n  var out = {}\n\n  utils.each(input, function (value) {\n    if (!value.hasOwnProperty(key)) {\n      return\n    }\n\n    var keyname = value[key]\n    var newValue = utils.extend({}, value)\n    delete newValue[key]\n\n    if (!out[keyname]) {\n      out[keyname] = []\n    }\n\n    out[keyname].push(newValue)\n  })\n\n  return out\n}\n\n/**\n * Join the input with a string.\n *\n * @example\n * // my_array = ['foo', 'bar', 'baz']\n * {{ my_array|join(', ') }}\n * // => foo, bar, baz\n *\n * @example\n * // my_key_object = { a: 'foo', b: 'bar', c: 'baz' }\n * {{ my_key_object|join(' and ') }}\n * // => foo and bar and baz\n *\n * @param  {*}  input\n * @param  {string} glue    String value to join items together.\n * @return {string}\n */\nexports.join = function (input, glue) {\n  if (utils.isArray(input)) {\n    return input.join(glue)\n  }\n\n  if (typeof input === 'object') {\n    var out = []\n    utils.each(input, function (value) {\n      out.push(value)\n    })\n    return out.join(glue)\n  }\n  return input\n}\n\n/**\n * Return a string representation of an JavaScript object.\n *\n * Backwards compatible with swig@0.x.x using `json_encode`.\n *\n * @example\n * // val = { a: 'b' }\n * {{ val|json }}\n * // => {\"a\":\"b\"}\n *\n * @example\n * // val = { a: 'b' }\n * {{ val|json(4) }}\n * // => {\n * //        \"a\": \"b\"\n * //    }\n *\n * @param  {*}    input\n * @param  {number}  [indent]  Number of spaces to indent for pretty-formatting.\n * @return {string}           A valid JSON string.\n */\nexports.json = function (input, indent) {\n  return JSON.stringify(input, null, indent || 0)\n}\nexports.json_encode = exports.json\n\n/**\n * Get the last item in an array or character in a string. All other objects will attempt to return the last value available.\n *\n * @example\n * // my_arr = ['a', 'b', 'c']\n * {{ my_arr|last }}\n * // => c\n *\n * @example\n * // my_val = 'Tacos'\n * {{ my_val|last }}\n * // s\n *\n * @param  {*} input\n * @return {*}          The last item of the array or last character of the string.input.\n */\nexports.last = function (input) {\n  if (typeof input === 'object' && !utils.isArray(input)) {\n    var keys = utils.keys(input)\n    return input[keys[keys.length - 1]]\n  }\n\n  if (typeof input === 'string') {\n    return input.charAt(input.length - 1)\n  }\n\n  return input[input.length - 1]\n}\n\n/**\n * Get the number of items in an array, string, or object.\n *\n * @example\n * // my_arr = ['a', 'b', 'c']\n * {{ my_arr|length }}\n * // => 3\n *\n * @example\n * // my_str = 'Tacos'\n * {{ my_str|length }}\n * // => 5\n *\n * @example\n * // my_obj = {a: 5, b: 20}\n * {{ my_obj|length }}\n * // => 2\n *\n * @param  {*} input\n * @return {*}          The length of the input\n */\nexports.length = function (input) {\n  if (typeof input === 'object' && !utils.isArray(input)) {\n    var keys = utils.keys(input)\n    return keys.length\n  }\n  if (input.hasOwnProperty('length')) {\n    return input.length\n  }\n  return ''\n}\n\n/**\n * Return the input in all lowercase letters.\n *\n * @example\n * {{ \"FOOBAR\"|lower }}\n * // => foobar\n *\n * @example\n * // myObj = { a: 'FOO', b: 'BAR' }\n * {{ myObj|lower|join('') }}\n * // => foobar\n *\n * @param  {*}  input\n * @return {*}          Returns the same type as the input.\n */\nexports.lower = function (input) {\n  var out = iterateFilter.apply(exports.lower, arguments)\n  if (out !== undefined) {\n    return out\n  }\n\n  return input.toString().toLowerCase()\n}\n\n/**\n * Deprecated in favor of <a href=\"#safe\">safe</a>.\n */\nexports.raw = function (input) {\n  return exports.safe(input)\n}\nexports.raw.safe = true\n\n/**\n * Returns a new string with the matched search pattern replaced by the given replacement string. Uses JavaScript's built-in String.replace() method.\n *\n * @example\n * // my_var = 'foobar';\n * {{ my_var|replace('o', 'e', 'g') }}\n * // => feebar\n *\n * @example\n * // my_var = \"farfegnugen\";\n * {{ my_var|replace('^f', 'p') }}\n * // => parfegnugen\n *\n * @example\n * // my_var = 'a1b2c3';\n * {{ my_var|replace('\\w', '0', 'g') }}\n * // => 010203\n *\n * @param  {string} input\n * @param  {string} search      String or pattern to replace from the input.\n * @param  {string} replacement String to replace matched pattern.\n * @param  {string} [flags]      Regular Expression flags. 'g': global match, 'i': ignore case, 'm': match over multiple lines\n * @return {string}             Replaced string.\n */\nexports.replace = function (input, search, replacement, flags) {\n  var r = new RegExp(search, flags)\n  return input.replace(r, replacement)\n}\n\n/**\n * Reverse sort the input. This is an alias for <code data-language=\"swig\">{{ input|sort(true) }}</code>.\n *\n * @example\n * // val = [1, 2, 3];\n * {{ val|reverse }}\n * // => 3,2,1\n *\n * @param  {array}  input\n * @return {array}        Reversed array. The original input object is returned if it was not an array.\n */\nexports.reverse = function (input) {\n  return exports.sort(input, true)\n}\n\n/**\n * Forces the input to not be auto-escaped. Use this only on content that you know is safe to be rendered on your page.\n *\n * @example\n * // my_var = \"<p>Stuff</p>\";\n * {{ my_var|safe }}\n * // => <p>Stuff</p>\n *\n * @param  {*}  input\n * @return {*}          The input exactly how it was given, regardless of autoescaping status.\n */\nexports.safe = function (input) {\n  // This is a magic filter. Its logic is hard-coded into Swig's parser.\n  return input\n}\nexports.safe.safe = true\n\n/**\n * Sort the input in an ascending direction.\n * If given an object, will return the keys as a sorted array.\n * If given a string, each character will be sorted individually.\n *\n * @example\n * // val = [2, 6, 4];\n * {{ val|sort }}\n * // => 2,4,6\n *\n * @example\n * // val = 'zaq';\n * {{ val|sort }}\n * // => aqz\n *\n * @example\n * // val = { bar: 1, foo: 2 }\n * {{ val|sort(true) }}\n * // => foo,bar\n *\n * @param  {*} input\n * @param {boolean} [reverse=false] Output is given reverse-sorted if true.\n * @return {*}        Sorted array;\n */\nexports.sort = function (input, reverse) {\n  var out, clone\n  if (utils.isArray(input)) {\n    clone = utils.extend([], input)\n    out = clone.sort()\n  } else {\n    switch (typeof input) {\n      case 'object':\n        out = utils.keys(input).sort()\n        break\n      case 'string':\n        out = input.split('')\n        if (reverse) {\n          return out.reverse().join('')\n        }\n        return out.sort().join('')\n    }\n  }\n\n  if (out && reverse) {\n    return out.reverse()\n  }\n\n  return out || input\n}\n\n/**\n * Strip HTML tags.\n *\n * @example\n * // stuff = '<p>foobar</p>';\n * {{ stuff|striptags }}\n * // => foobar\n *\n * @param  {*}  input\n * @return {*}        Returns the same object as the input, but with all string values stripped of tags.\n */\nexports.striptags = function (input) {\n  var out = iterateFilter.apply(exports.striptags, arguments)\n  if (out !== undefined) {\n    return out\n  }\n\n  return input.toString().replace(/(<([^>]+)>)/gi, '')\n}\n\n/**\n * Capitalizes every word given and lower-cases all other letters.\n *\n * @example\n * // my_str = 'this is soMe text';\n * {{ my_str|title }}\n * // => This Is Some Text\n *\n * @example\n * // my_arr = ['hi', 'this', 'is', 'an', 'array'];\n * {{ my_arr|title|join(' ') }}\n * // => Hi This Is An Array\n *\n * @param  {*}  input\n * @return {*}        Returns the same object as the input, but with all words in strings title-cased.\n */\nexports.title = function (input) {\n  var out = iterateFilter.apply(exports.title, arguments)\n  if (out !== undefined) {\n    return out\n  }\n\n  return input.toString().replace(/\\w\\S*/g, function (str) {\n    return str.charAt(0).toUpperCase() + str.substr(1).toLowerCase()\n  })\n}\n\n/**\n * Remove all duplicate items from an array.\n *\n * @example\n * // my_arr = [1, 2, 3, 4, 4, 3, 2, 1];\n * {{ my_arr|uniq|join(',') }}\n * // => 1,2,3,4\n *\n * @param  {array}  input\n * @return {array}        Array with unique items. If input was not an array, the original item is returned untouched.\n */\nexports.uniq = function (input) {\n  var result\n\n  if (!input || !utils.isArray(input)) {\n    return ''\n  }\n\n  result = []\n  utils.each(input, function (v) {\n    if (result.indexOf(v) === -1) {\n      result.push(v)\n    }\n  })\n  return result\n}\n\n/**\n * Convert the input to all uppercase letters. If an object or array is provided, all values will be uppercased.\n *\n * @example\n * // my_str = 'tacos';\n * {{ my_str|upper }}\n * // => TACOS\n *\n * @example\n * // my_arr = ['tacos', 'burritos'];\n * {{ my_arr|upper|join(' & ') }}\n * // => TACOS & BURRITOS\n *\n * @param  {*}  input\n * @return {*}        Returns the same type as the input, with all strings upper-cased.\n */\nexports.upper = function (input) {\n  var out = iterateFilter.apply(exports.upper, arguments)\n  if (out !== undefined) {\n    return out\n  }\n\n  return input.toString().toUpperCase()\n}\n\n/**\n * URL-encode a string. If an object or array is passed, all values will be URL-encoded.\n *\n * @example\n * // my_str = 'param=1&anotherParam=2';\n * {{ my_str|url_encode }}\n * // => param%3D1%26anotherParam%3D2\n *\n * @param  {*} input\n * @return {*}       URL-encoded string.\n */\nexports.url_encode = function (input) {\n  var out = iterateFilter.apply(exports.url_encode, arguments)\n  if (out !== undefined) {\n    return out\n  }\n  return encodeURIComponent(input)\n}\n\n/**\n * URL-decode a string. If an object or array is passed, all values will be URL-decoded.\n *\n * @example\n * // my_str = 'param%3D1%26anotherParam%3D2';\n * {{ my_str|url_decode }}\n * // => param=1&anotherParam=2\n *\n * @param  {*} input\n * @return {*}       URL-decoded string.\n */\nexports.url_decode = function (input) {\n  var out = iterateFilter.apply(exports.url_decode, arguments)\n  if (out !== undefined) {\n    return out\n  }\n  return decodeURIComponent(input)\n}\n\n\n//# sourceURL=webpack:///../node_modules/swig-templates/lib/filters.js?");

/***/ }),

/***/ "../node_modules/swig-templates/lib/lexer.js":
/*!***************************************************!*\
  !*** ../node_modules/swig-templates/lib/lexer.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var utils = __webpack_require__(/*! ./utils */ \"../node_modules/swig-templates/lib/utils.js\")\n\n/**\n * A lexer token.\n * @typedef {object} LexerToken\n * @property {string} match  The string that was matched.\n * @property {number} type   Lexer type enum.\n * @property {number} length Length of the original string processed.\n */\n\n/**\n * Enum for token types.\n * @readonly\n * @enum {number}\n */\nvar TYPES = {\n  /** Whitespace */\n  WHITESPACE: 0,\n  /** Plain string */\n  STRING: 1,\n  /** Variable filter */\n  FILTER: 2,\n  /** Empty variable filter */\n  FILTEREMPTY: 3,\n  /** Function */\n  FUNCTION: 4,\n  /** Function with no arguments */\n  FUNCTIONEMPTY: 5,\n  /** Open parenthesis */\n  PARENOPEN: 6,\n  /** Close parenthesis */\n  PARENCLOSE: 7,\n  /** Comma */\n  COMMA: 8,\n  /** Variable */\n  VAR: 9,\n  /** Number */\n  NUMBER: 10,\n  /** Math operator */\n  OPERATOR: 11,\n  /** Open square bracket */\n  BRACKETOPEN: 12,\n  /** Close square bracket */\n  BRACKETCLOSE: 13,\n  /** Key on an object using dot-notation */\n  DOTKEY: 14,\n  /** Start of an array */\n  ARRAYOPEN: 15,\n  /** End of an array\n   * Currently unused\n   ARRAYCLOSE: 16, */\n  /** Open curly brace */\n  CURLYOPEN: 17,\n  /** Close curly brace */\n  CURLYCLOSE: 18,\n  /** Colon (:) */\n  COLON: 19,\n  /** JavaScript-valid comparator */\n  COMPARATOR: 20,\n  /** Boolean logic */\n  LOGIC: 21,\n  /** Boolean logic \"not\" */\n  NOT: 22,\n  /** true or false */\n  BOOL: 23,\n  /** Variable assignment */\n  ASSIGNMENT: 24,\n  /** Start of a method */\n  METHODOPEN: 25,\n  /** End of a method\n   * Currently unused\n   METHODEND: 26, */\n  /** Unknown type */\n  UNKNOWN: 100\n}\nvar rules = [\n  {\n    type: TYPES.WHITESPACE,\n    regex: [/^\\s+/]\n  },\n  {\n    type: TYPES.STRING,\n    regex: [/^\"\"/, /^\".*?[^\\\\]\"/, /^''/, /^'.*?[^\\\\]'/]\n  },\n  {\n    type: TYPES.FILTER,\n    regex: [/^\\|\\s*(\\w+)\\(/],\n    idx: 1\n  },\n  {\n    type: TYPES.FILTEREMPTY,\n    regex: [/^\\|\\s*(\\w+)/],\n    idx: 1\n  },\n  {\n    type: TYPES.FUNCTIONEMPTY,\n    regex: [/^\\s*(\\w+)\\(\\)/],\n    idx: 1\n  },\n  {\n    type: TYPES.FUNCTION,\n    regex: [/^\\s*(\\w+)\\(/],\n    idx: 1\n  },\n  {\n    type: TYPES.PARENOPEN,\n    regex: [/^\\(/]\n  },\n  {\n    type: TYPES.PARENCLOSE,\n    regex: [/^\\)/]\n  },\n  {\n    type: TYPES.COMMA,\n    regex: [/^,/]\n  },\n  {\n    type: TYPES.LOGIC,\n    regex: [/^(&&|\\|\\|)\\s*/, /^(and|or)\\s+/],\n    idx: 1,\n    replace: {\n      and: '&&',\n      or: '||'\n    }\n  },\n  {\n    type: TYPES.COMPARATOR,\n    regex: [/^(===|==|!==|!=|<=|<|>=|>|in\\s|gte\\s|gt\\s|lte\\s|lt\\s)\\s*/],\n    idx: 1,\n    replace: {\n      gte: '>=',\n      gt: '>',\n      lte: '<=',\n      lt: '<'\n    }\n  },\n  {\n    type: TYPES.ASSIGNMENT,\n    regex: [/^(=|\\+=|-=|\\*=|\\/=)/]\n  },\n  {\n    type: TYPES.NOT,\n    regex: [/^!\\s*/, /^not\\s+/],\n    replace: {\n      not: '!'\n    }\n  },\n  {\n    type: TYPES.BOOL,\n    regex: [/^(true|false)\\s+/, /^(true|false)$/],\n    idx: 1\n  },\n  {\n    type: TYPES.VAR,\n    regex: [/^[a-zA-Z_$]\\w*((\\.\\$?\\w*)+)?/, /^[a-zA-Z_$]\\w*/]\n  },\n  {\n    type: TYPES.BRACKETOPEN,\n    regex: [/^\\[/]\n  },\n  {\n    type: TYPES.BRACKETCLOSE,\n    regex: [/^\\]/]\n  },\n  {\n    type: TYPES.CURLYOPEN,\n    regex: [/^\\{/]\n  },\n  {\n    type: TYPES.COLON,\n    regex: [/^:/]\n  },\n  {\n    type: TYPES.CURLYCLOSE,\n    regex: [/^\\}/]\n  },\n  {\n    type: TYPES.DOTKEY,\n    regex: [/^\\.(\\w+)/],\n    idx: 1\n  },\n  {\n    type: TYPES.NUMBER,\n    regex: [/^[+-]?\\d+(\\.\\d+)?/]\n  },\n  {\n    type: TYPES.OPERATOR,\n    regex: [/^(\\+|-|\\/|\\*|%)/]\n  }\n]\n\nexports.types = TYPES\n\n/**\n * Return the token type object for a single chunk of a string.\n * @param  {string} str String chunk.\n * @return {LexerToken}     Defined type, potentially stripped or replaced with more suitable content.\n * @private\n */\nfunction reader (str) {\n  var matched\n\n  utils.some(rules, function (rule) {\n    return utils.some(rule.regex, function (regex) {\n      var match = str.match(regex)\n      var normalized\n\n      if (!match) {\n        return\n      }\n\n      normalized = match[rule.idx || 0].replace(/\\s*$/, '')\n      normalized =\n        rule.hasOwnProperty('replace') &&\n        rule.replace.hasOwnProperty(normalized)\n          ? rule.replace[normalized]\n          : normalized\n\n      matched = {\n        match: normalized,\n        type: rule.type,\n        length: match[0].length\n      }\n      return true\n    })\n  })\n\n  if (!matched) {\n    matched = {\n      match: str,\n      type: TYPES.UNKNOWN,\n      length: str.length\n    }\n  }\n\n  return matched\n}\n\n/**\n * Read a string and break it into separate token types.\n * @param  {string} str\n * @return {Array.LexerToken}     Array of defined types, potentially stripped or replaced with more suitable content.\n * @private\n */\nexports.read = function (str) {\n  var offset = 0\n  var tokens = []\n  var substr\n  var match\n  while (offset < str.length) {\n    substr = str.substring(offset)\n    match = reader(substr)\n    offset += match.length\n    tokens.push(match)\n  }\n  return tokens\n}\n\n\n//# sourceURL=webpack:///../node_modules/swig-templates/lib/lexer.js?");

/***/ }),

/***/ "../node_modules/swig-templates/lib/loaders/filesystem.js":
/*!****************************************************************!*\
  !*** ../node_modules/swig-templates/lib/loaders/filesystem.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var fs = __webpack_require__(/*! fs */ \"fs\")\nvar path = __webpack_require__(/*! path */ \"path\")\n\n/**\n * Loads templates from the file system.\n * @alias swig.loaders.fs\n * @example\n * swig.setDefaults({ loader: swig.loaders.fs() });\n * @example\n * // Load Templates from a specific directory (does not require using relative paths in your templates)\n * swig.setDefaults({ loader: swig.loaders.fs(__dirname + '/templates' )});\n * @param {string}   [basepath='']     Path to the templates as string. Assigning this value allows you to use semi-absolute paths to templates instead of relative paths.\n * @param {string}   [encoding='utf8']   Template encoding\n */\nmodule.exports = function (basepath, encoding) {\n  var ret = {}\n\n  encoding = encoding || 'utf8'\n  basepath = basepath ? path.resolve(basepath) : null\n\n  /**\n   * Resolves <var>to</var> to an absolute path or unique identifier. This is used for building correct, normalized, and absolute paths to a given template.\n   * @alias resolve\n   * @param  {string} to        Non-absolute identifier or pathname to a file.\n   * @param  {string} [from]    If given, should attempt to find the <var>to</var> path in relation to this given, known path.\n   * @return {string}\n   */\n  ret.resolve = function (to, from) {\n    if (basepath) {\n      from = basepath\n    } else {\n      from = from ? path.dirname(from) : process.cwd()\n    }\n    return path.resolve(from, to)\n  }\n\n  /**\n   * Loads a single template. Given a unique <var>identifier</var> found by the <var>resolve</var> method this should return the given template.\n   * @alias load\n   * @param  {string}   identifier  Unique identifier of a template (possibly an absolute path).\n   * @param  {function} [cb]        Asynchronous callback function. If not provided, this method should run synchronously.\n   * @return {string}               Template source string.\n   */\n  ret.load = function (identifier, cb) {\n    if (!fs || (cb && !fs.readFile) || !fs.readFileSync) {\n      throw new Error(\n        'Unable to find file ' +\n          identifier +\n          ' because there is no filesystem to read from.'\n      )\n    }\n\n    identifier = ret.resolve(identifier)\n\n    if (cb) {\n      fs.readFile(identifier, encoding, cb)\n      return\n    }\n    return fs.readFileSync(identifier, encoding)\n  }\n\n  return ret\n}\n\n\n//# sourceURL=webpack:///../node_modules/swig-templates/lib/loaders/filesystem.js?");

/***/ }),

/***/ "../node_modules/swig-templates/lib/loaders/index.js":
/*!***********************************************************!*\
  !*** ../node_modules/swig-templates/lib/loaders/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @namespace TemplateLoader\n * @description Swig is able to accept custom template loaders written by you, so that your templates can come from your favorite storage medium without needing to be part of the core library.\n * A template loader consists of two methods: <var>resolve</var> and <var>load</var>. Each method is used internally by Swig to find and load the source of the template before attempting to parse and compile it.\n * @example\n * // A theoretical memcached loader\n * var path = require('path'),\n *   Memcached = require('memcached');\n * function memcachedLoader(locations, options) {\n *   var memcached = new Memcached(locations, options);\n *   return {\n *     resolve: function (to, from) {\n *       return path.resolve(from, to);\n *     },\n *     load: function (identifier, cb) {\n *       memcached.get(identifier, function (err, data) {\n *         // if (!data) { load from filesystem; }\n *         cb(err, data);\n *       });\n *     }\n *   };\n * };\n * // Tell swig about the loader:\n * swig.setDefaults({ loader: memcachedLoader(['192.168.0.2']) });\n */\n\n/**\n * @function\n * @name resolve\n * @memberof TemplateLoader\n * @description\n * Resolves <var>to</var> to an absolute path or unique identifier. This is used for building correct, normalized, and absolute paths to a given template.\n * @param  {string} to        Non-absolute identifier or pathname to a file.\n * @param  {string} [from]    If given, should attempt to find the <var>to</var> path in relation to this given, known path.\n * @return {string}\n */\n\n/**\n * @function\n * @name load\n * @memberof TemplateLoader\n * @description\n * Loads a single template. Given a unique <var>identifier</var> found by the <var>resolve</var> method this should return the given template.\n * @param  {string}   identifier  Unique identifier of a template (possibly an absolute path).\n * @param  {function} [cb]        Asynchronous callback function. If not provided, this method should run synchronously.\n * @return {string}               Template source string.\n */\n\n/**\n * @private\n */\nexports.fs = __webpack_require__(/*! ./filesystem */ \"../node_modules/swig-templates/lib/loaders/filesystem.js\")\nexports.memory = __webpack_require__(/*! ./memory */ \"../node_modules/swig-templates/lib/loaders/memory.js\")\n\n\n//# sourceURL=webpack:///../node_modules/swig-templates/lib/loaders/index.js?");

/***/ }),

/***/ "../node_modules/swig-templates/lib/loaders/memory.js":
/*!************************************************************!*\
  !*** ../node_modules/swig-templates/lib/loaders/memory.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var path = __webpack_require__(/*! path */ \"path\")\nvar utils = __webpack_require__(/*! ../utils */ \"../node_modules/swig-templates/lib/utils.js\")\n\n/**\n * Loads templates from a provided object mapping.\n * @alias swig.loaders.memory\n * @example\n * var templates = {\n *   \"layout\": \"{% block content %}{% endblock %}\",\n *   \"home.html\": \"{% extends 'layout.html' %}{% block content %}...{% endblock %}\"\n * };\n * swig.setDefaults({ loader: swig.loaders.memory(templates) });\n *\n * @param {object} mapping Hash object with template paths as keys and template sources as values.\n * @param {string} [basepath] Path to the templates as string. Assigning this value allows you to use semi-absolute paths to templates instead of relative paths.\n */\nmodule.exports = function (mapping, basepath) {\n  var ret = {}\n\n  basepath = basepath ? path.resolve(basepath) : null\n\n  /**\n   * Resolves <var>to</var> to an absolute path or unique identifier. This is used for building correct, normalized, and absolute paths to a given template.\n   * @alias resolve\n   * @param  {string} to        Non-absolute identifier or pathname to a file.\n   * @param  {string} [from]    If given, should attempt to find the <var>to</var> path in relation to this given, known path.\n   * @return {string}\n   */\n  ret.resolve = function (to, from) {\n    if (basepath) {\n      from = basepath\n    } else {\n      from = from ? path.dirname(from) : '/'\n    }\n    return path.resolve(from, to)\n  }\n\n  /**\n   * Loads a single template. Given a unique <var>identifier</var> found by the <var>resolve</var> method this should return the given template.\n   * @alias load\n   * @param  {string}   identifier  Unique identifier of a template (possibly an absolute path).\n   * @param  {function} [cb]        Asynchronous callback function. If not provided, this method should run synchronously.\n   * @return {string}               Template source string.\n   */\n  ret.load = function (pathname, cb) {\n    var src, paths\n\n    paths = [pathname, pathname.replace(/^(\\/|\\\\)/, '')]\n\n    src = mapping[paths[0]] || mapping[paths[1]]\n    if (!src) {\n      utils.throwError('Unable to find template \"' + pathname + '\".')\n    }\n\n    if (cb) {\n      cb(null, src)\n      return\n    }\n    return src\n  }\n\n  return ret\n}\n\n\n//# sourceURL=webpack:///../node_modules/swig-templates/lib/loaders/memory.js?");

/***/ }),

/***/ "../node_modules/swig-templates/lib/parser.js":
/*!****************************************************!*\
  !*** ../node_modules/swig-templates/lib/parser.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var utils = __webpack_require__(/*! ./utils */ \"../node_modules/swig-templates/lib/utils.js\")\nvar lexer = __webpack_require__(/*! ./lexer */ \"../node_modules/swig-templates/lib/lexer.js\")\n\nvar _t = lexer.types\nvar _reserved = [\n  'break',\n  'case',\n  'catch',\n  'continue',\n  'debugger',\n  'default',\n  'delete',\n  'do',\n  'else',\n  'finally',\n  'for',\n  'function',\n  'if',\n  'in',\n  'instanceof',\n  'new',\n  'return',\n  'switch',\n  'this',\n  'throw',\n  'try',\n  'typeof',\n  'var',\n  'void',\n  'while',\n  'with'\n]\n\n/**\n * Filters are simply functions that perform transformations on their first input argument.\n * Filters are run at render time, so they may not directly modify the compiled template structure in any way.\n * All of Swig's built-in filters are written in this same way. For more examples, reference the `filters.js` file in Swig's source.\n *\n * To disable auto-escaping on a custom filter, simply add a property to the filter method `safe = true;` and the output from this will not be escaped, no matter what the global settings are for Swig.\n *\n * @typedef {function} Filter\n *\n * @example\n * // This filter will return 'bazbop' if the idx on the input is not 'foobar'\n * swig.setFilter('foobar', function (input, idx) {\n *   return input[idx] === 'foobar' ? input[idx] : 'bazbop';\n * });\n * // myvar = ['foo', 'bar', 'baz', 'bop'];\n * // => {{ myvar|foobar(3) }}\n * // Since myvar[3] !== 'foobar', we render:\n * // => bazbop\n *\n * @example\n * // This filter will disable auto-escaping on its output:\n * function bazbop (input) { return input; }\n * bazbop.safe = true;\n * swig.setFilter('bazbop', bazbop);\n * // => {{ \"<p>\"|bazbop }}\n * // => <p>\n *\n * @param {*} input Input argument, automatically sent from Swig's built-in parser.\n * @param {...*} [args] All other arguments are defined by the Filter author.\n * @return {*}\n */\n\n/*!\n * Makes a string safe for a regular expression.\n * @param  {string} str\n * @return {string}\n * @private\n */\nfunction escapeRegExp (str) {\n  return str.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n}\n\n/**\n * Parse strings of variables and tags into tokens for future compilation.\n * @class\n * @param {array}   tokens     Pre-split tokens read by the Lexer.\n * @param {object}  filters    Keyed object of filters that may be applied to variables.\n * @param {boolean} autoescape Whether or not this should be autoescaped.\n * @param {number}  line       Beginning line number for the first token.\n * @param {string}  [filename] Name of the file being parsed.\n * @private\n */\nfunction TokenParser (tokens, filters, autoescape, line, filename) {\n  this.out = []\n  this.state = []\n  this.filterApplyIdx = []\n  this._parsers = {}\n  this.line = line\n  this.filename = filename\n  this.filters = filters\n  this.escape = autoescape\n\n  this.parse = function () {\n    var self = this\n\n    if (self._parsers.start) {\n      self._parsers.start.call(self)\n    }\n    utils.each(tokens, function (token, i) {\n      var prevToken = tokens[i - 1]\n      self.isLast = i === tokens.length - 1\n      if (prevToken) {\n        while (prevToken.type === _t.WHITESPACE) {\n          i -= 1\n          prevToken = tokens[i - 1]\n        }\n      }\n      self.prevToken = prevToken\n      self.parseToken(token)\n    })\n    if (self._parsers.end) {\n      self._parsers.end.call(self)\n    }\n\n    if (self.escape) {\n      self.filterApplyIdx = [0]\n      if (typeof self.escape === 'string') {\n        self.parseToken({ type: _t.FILTER, match: 'e' })\n        self.parseToken({ type: _t.COMMA, match: ',' })\n        self.parseToken({ type: _t.STRING, match: String(autoescape) })\n        self.parseToken({ type: _t.PARENCLOSE, match: ')' })\n      } else {\n        self.parseToken({ type: _t.FILTEREMPTY, match: 'e' })\n      }\n    }\n\n    return self.out\n  }\n}\n\nTokenParser.prototype = {\n  /**\n   * Set a custom method to be called when a token type is found.\n   *\n   * @example\n   * parser.on(types.STRING, function (token) {\n   *   this.out.push(token.match);\n   * });\n   * @example\n   * parser.on('start', function () {\n   *   this.out.push('something at the beginning of your args')\n   * });\n   * parser.on('end', function () {\n   *   this.out.push('something at the end of your args');\n   * });\n   *\n   * @param  {number}   type Token type ID. Found in the Lexer.\n   * @param  {Function} fn   Callback function. Return true to continue executing the default parsing function.\n   * @return {undefined}\n   */\n  on: function (type, fn) {\n    this._parsers[type] = fn\n  },\n\n  /**\n   * Parse a single token.\n   * @param  {{match: string, type: number, line: number}} token Lexer token object.\n   * @return {undefined}\n   * @private\n   */\n  parseToken: function (token) {\n    var self = this\n    var fn = self._parsers[token.type] || self._parsers['*']\n    var match = token.match\n    var prevToken = self.prevToken\n    var prevTokenType = prevToken ? prevToken.type : null\n    var lastState = self.state.length ? self.state[self.state.length - 1] : null\n    var temp\n\n    if (fn && typeof fn === 'function') {\n      if (!fn.call(this, token)) {\n        return\n      }\n    }\n\n    if (\n      lastState &&\n      prevToken &&\n      lastState === _t.FILTER &&\n      prevTokenType === _t.FILTER &&\n      token.type !== _t.PARENCLOSE &&\n      token.type !== _t.COMMA &&\n      token.type !== _t.OPERATOR &&\n      token.type !== _t.FILTER &&\n      token.type !== _t.FILTEREMPTY\n    ) {\n      self.out.push(', ')\n    }\n\n    if (lastState && lastState === _t.METHODOPEN) {\n      self.state.pop()\n      if (token.type !== _t.PARENCLOSE) {\n        self.out.push(', ')\n      }\n    }\n\n    switch (token.type) {\n      case _t.WHITESPACE:\n        break\n\n      case _t.STRING:\n        self.filterApplyIdx.push(self.out.length)\n        self.out.push(match.replace(/\\\\/g, '\\\\\\\\'))\n        break\n\n      case _t.NUMBER:\n      case _t.BOOL:\n        self.filterApplyIdx.push(self.out.length)\n        self.out.push(match)\n        break\n\n      case _t.FILTER:\n        if (\n          !self.filters.hasOwnProperty(match) ||\n          typeof self.filters[match] !== 'function'\n        ) {\n          utils.throwError(\n            'Invalid filter \"' + match + '\"',\n            self.line,\n            self.filename\n          )\n        }\n        self.escape = self.filters[match].safe ? false : self.escape\n        self.out.splice(\n          self.filterApplyIdx[self.filterApplyIdx.length - 1],\n          0,\n          '_filters[\"' + match + '\"]('\n        )\n        self.state.push(token.type)\n        break\n\n      case _t.FILTEREMPTY:\n        if (\n          !self.filters.hasOwnProperty(match) ||\n          typeof self.filters[match] !== 'function'\n        ) {\n          utils.throwError(\n            'Invalid filter \"' + match + '\"',\n            self.line,\n            self.filename\n          )\n        }\n        self.escape = self.filters[match].safe ? false : self.escape\n        self.out.splice(\n          self.filterApplyIdx[self.filterApplyIdx.length - 1],\n          0,\n          '_filters[\"' + match + '\"]('\n        )\n        self.out.push(')')\n        break\n\n      case _t.FUNCTION:\n      case _t.FUNCTIONEMPTY:\n        self.out.push(\n          '((typeof _ctx.' +\n            match +\n            ' !== \"undefined\") ? _ctx.' +\n            match +\n            ' : ((typeof ' +\n            match +\n            ' !== \"undefined\") ? ' +\n            match +\n            ' : _fn))('\n        )\n        self.escape = false\n        if (token.type === _t.FUNCTIONEMPTY) {\n          self.out[self.out.length - 1] = self.out[self.out.length - 1] + ')'\n        } else {\n          self.state.push(token.type)\n        }\n        self.filterApplyIdx.push(self.out.length - 1)\n        break\n\n      case _t.PARENOPEN:\n        self.state.push(token.type)\n        if (self.filterApplyIdx.length) {\n          self.out.splice(\n            self.filterApplyIdx[self.filterApplyIdx.length - 1],\n            0,\n            '('\n          )\n          if (prevToken && prevTokenType === _t.VAR) {\n            temp = prevToken.match.split('.').slice(0, -1)\n            self.out.push(' || _fn).call(' + self.checkMatch(temp))\n            self.state.push(_t.METHODOPEN)\n            self.escape = false\n          } else {\n            self.out.push(' || _fn)(')\n          }\n          self.filterApplyIdx.push(self.out.length - 3)\n        } else {\n          self.out.push('(')\n          self.filterApplyIdx.push(self.out.length - 1)\n        }\n        break\n\n      case _t.PARENCLOSE:\n        temp = self.state.pop()\n        if (\n          temp !== _t.PARENOPEN &&\n          temp !== _t.FUNCTION &&\n          temp !== _t.FILTER\n        ) {\n          utils.throwError('Mismatched nesting state', self.line, self.filename)\n        }\n        self.out.push(')')\n        // Once off the previous entry\n        self.filterApplyIdx.pop()\n        if (temp !== _t.FILTER) {\n          // Once for the open paren\n          self.filterApplyIdx.pop()\n        }\n        break\n\n      case _t.COMMA:\n        if (\n          lastState !== _t.FUNCTION &&\n          lastState !== _t.FILTER &&\n          lastState !== _t.ARRAYOPEN &&\n          lastState !== _t.CURLYOPEN &&\n          lastState !== _t.PARENOPEN &&\n          lastState !== _t.COLON\n        ) {\n          utils.throwError('Unexpected comma', self.line, self.filename)\n        }\n        if (lastState === _t.COLON) {\n          self.state.pop()\n        }\n        self.out.push(', ')\n        self.filterApplyIdx.pop()\n        break\n\n      case _t.LOGIC:\n      case _t.COMPARATOR:\n        if (\n          !prevToken ||\n          prevTokenType === _t.COMMA ||\n          prevTokenType === token.type ||\n          prevTokenType === _t.BRACKETOPEN ||\n          prevTokenType === _t.CURLYOPEN ||\n          prevTokenType === _t.PARENOPEN ||\n          prevTokenType === _t.FUNCTION\n        ) {\n          utils.throwError('Unexpected logic', self.line, self.filename)\n        }\n        self.out.push(token.match)\n        break\n\n      case _t.NOT:\n        self.out.push(token.match)\n        break\n\n      case _t.VAR:\n        self.parseVar(token, match, lastState)\n        break\n\n      case _t.BRACKETOPEN:\n        if (\n          !prevToken ||\n          (prevTokenType !== _t.VAR &&\n            prevTokenType !== _t.BRACKETCLOSE &&\n            prevTokenType !== _t.PARENCLOSE)\n        ) {\n          self.state.push(_t.ARRAYOPEN)\n          self.filterApplyIdx.push(self.out.length)\n        } else {\n          self.state.push(token.type)\n        }\n        self.out.push('[')\n        break\n\n      case _t.BRACKETCLOSE:\n        temp = self.state.pop()\n        if (temp !== _t.BRACKETOPEN && temp !== _t.ARRAYOPEN) {\n          utils.throwError(\n            'Unexpected closing square bracket',\n            self.line,\n            self.filename\n          )\n        }\n        self.out.push(']')\n        self.filterApplyIdx.pop()\n        break\n\n      case _t.CURLYOPEN:\n        self.state.push(token.type)\n        self.out.push('{')\n        self.filterApplyIdx.push(self.out.length - 1)\n        break\n\n      case _t.COLON:\n        if (lastState !== _t.CURLYOPEN) {\n          utils.throwError('Unexpected colon', self.line, self.filename)\n        }\n        self.state.push(token.type)\n        self.out.push(':')\n        self.filterApplyIdx.pop()\n        break\n\n      case _t.CURLYCLOSE:\n        if (lastState === _t.COLON) {\n          self.state.pop()\n        }\n        if (self.state.pop() !== _t.CURLYOPEN) {\n          utils.throwError(\n            'Unexpected closing curly brace',\n            self.line,\n            self.filename\n          )\n        }\n        self.out.push('}')\n\n        self.filterApplyIdx.pop()\n        break\n\n      case _t.DOTKEY:\n        if (\n          !prevToken ||\n          (prevTokenType !== _t.VAR &&\n            prevTokenType !== _t.BRACKETCLOSE &&\n            prevTokenType !== _t.DOTKEY &&\n            prevTokenType !== _t.PARENCLOSE &&\n            prevTokenType !== _t.FUNCTIONEMPTY &&\n            prevTokenType !== _t.FILTEREMPTY &&\n            prevTokenType !== _t.CURLYCLOSE)\n        ) {\n          utils.throwError(\n            'Unexpected key \"' + match + '\"',\n            self.line,\n            self.filename\n          )\n        }\n        self.out.push('.' + match)\n        break\n\n      case _t.OPERATOR:\n        self.out.push(' ' + match + ' ')\n        self.filterApplyIdx.pop()\n        break\n    }\n  },\n\n  /**\n   * Parse variable token\n   * @param  {{match: string, type: number, line: number}} token      Lexer token object.\n   * @param  {string} match       Shortcut for token.match\n   * @param  {number} lastState   Lexer token type state.\n   * @return {undefined}\n   * @private\n   */\n  parseVar: function (token, match, lastState) {\n    var self = this\n\n    match = match.split('.')\n\n    if (_reserved.indexOf(match[0]) !== -1) {\n      utils.throwError(\n        'Reserved keyword \"' +\n          match[0] +\n          '\" attempted to be used as a variable',\n        self.line,\n        self.filename\n      )\n    }\n\n    self.filterApplyIdx.push(self.out.length)\n    if (lastState === _t.CURLYOPEN) {\n      if (match.length > 1) {\n        utils.throwError('Unexpected dot', self.line, self.filename)\n      }\n      self.out.push(match[0])\n      return\n    }\n\n    self.out.push(self.checkMatch(match))\n  },\n\n  /**\n   * Return contextual dot-check string for a match\n   * @param  {string} match       Shortcut for token.match\n   * @private\n   */\n  checkMatch: function (match) {\n    var temp = match[0]\n    var result\n\n    function checkDot (ctx) {\n      var c = ctx + temp\n      var m = match\n      var build = ''\n\n      build = '(typeof ' + c + ' !== \"undefined\" && ' + c + ' !== null'\n      utils.each(m, function (v, i) {\n        if (i === 0) {\n          return\n        }\n        build +=\n          ' && ' +\n          c +\n          '.' +\n          v +\n          ' !== undefined && ' +\n          c +\n          '.' +\n          v +\n          ' !== null'\n        c += '.' + v\n      })\n      build += ')'\n\n      return build\n    }\n\n    function buildDot (ctx) {\n      return '(' + checkDot(ctx) + ' ? ' + ctx + match.join('.') + ' : \"\")'\n    }\n    result =\n      '(' +\n      checkDot('_ctx.') +\n      ' ? ' +\n      buildDot('_ctx.') +\n      ' : ' +\n      buildDot('') +\n      ')'\n    return '(' + result + ' !== null ? ' + result + ' : ' + '\"\" )'\n  }\n}\n\n/**\n * Parse a source string into tokens that are ready for compilation.\n *\n * @example\n * exports.parse('{{ tacos }}', {}, tags, filters);\n * // => [{ compile: [Function], ... }]\n *\n * @params {object} swig    The current Swig instance\n * @param  {string} source  Swig template source.\n * @param  {object} opts    Swig options object.\n * @param  {object} tags    Keyed object of tags that can be parsed and compiled.\n * @param  {object} filters Keyed object of filters that may be applied to variables.\n * @return {array}          List of tokens ready for compilation.\n */\nexports.parse = function (swig, source, opts, tags, filters) {\n  source = source.replace(/\\r\\n/g, '\\n')\n  var escape = opts.autoescape\n  var tagOpen = opts.tagControls[0]\n  var tagClose = opts.tagControls[1]\n  var varOpen = opts.varControls[0]\n  var varClose = opts.varControls[1]\n  var escapedTagOpen = escapeRegExp(tagOpen)\n  var escapedTagClose = escapeRegExp(tagClose)\n  var escapedVarOpen = escapeRegExp(varOpen)\n  var escapedVarClose = escapeRegExp(varClose)\n  var tagStrip = new RegExp(\n    '^' + escapedTagOpen + '-?\\\\s*-?|-?\\\\s*-?' + escapedTagClose + '$',\n    'g'\n  )\n  var tagStripBefore = new RegExp('^' + escapedTagOpen + '-')\n  var tagStripAfter = new RegExp('-' + escapedTagClose + '$')\n  var varStrip = new RegExp(\n    '^' + escapedVarOpen + '-?\\\\s*-?|-?\\\\s*-?' + escapedVarClose + '$',\n    'g'\n  )\n  var varStripBefore = new RegExp('^' + escapedVarOpen + '-')\n  var varStripAfter = new RegExp('-' + escapedVarClose + '$')\n  var cmtOpen = opts.cmtControls[0]\n  var cmtClose = opts.cmtControls[1]\n  var anyChar = '[\\\\s\\\\S]*?'\n  // Split the template source based on variable, tag, and comment blocks\n  // /(\\{%[\\s\\S]*?%\\}|\\{\\{[\\s\\S]*?\\}\\}|\\{#[\\s\\S]*?#\\})/\n  var splitter = new RegExp(\n    '(' +\n      escapedTagOpen +\n      anyChar +\n      escapedTagClose +\n      '|' +\n      escapedVarOpen +\n      anyChar +\n      escapedVarClose +\n      '|' +\n      escapeRegExp(cmtOpen) +\n      anyChar +\n      escapeRegExp(cmtClose) +\n      ')'\n  )\n  var line = 1\n  var stack = []\n  var parent = null\n  var tokens = []\n  var blocks = {}\n  var inRaw = false\n  var stripNext\n\n  /**\n   * Parse a variable.\n   * @param  {string} str  String contents of the variable, between <i>{{</i> and <i>}}</i>\n   * @param  {number} line The line number that this variable starts on.\n   * @return {VarToken}      Parsed variable token object.\n   * @private\n   */\n  function parseVariable (str, line) {\n    var lexedTokens = lexer.read(utils.strip(str))\n    var parser\n    var out\n\n    parser = new TokenParser(lexedTokens, filters, escape, line, opts.filename)\n    out = parser.parse().join('')\n\n    if (parser.state.length) {\n      utils.throwError('Unable to parse \"' + str + '\"', line, opts.filename)\n    }\n\n    /**\n     * A parsed variable token.\n     * @typedef {object} VarToken\n     * @property {function} compile Method for compiling this token.\n     */\n    return {\n      compile: function () {\n        return '_output += ' + out + ';\\n'\n      }\n    }\n  }\n  exports.parseVariable = parseVariable\n\n  /**\n   * Parse a tag.\n   * @param  {string} str  String contents of the tag, between <i>{%</i> and <i>%}</i>\n   * @param  {number} line The line number that this tag starts on.\n   * @return {TagToken}      Parsed token object.\n   * @private\n   */\n  function parseTag (str, line) {\n    var lexedTokens, parser, chunks, tagName, tag, args, last\n\n    if (utils.startsWith(str, 'end')) {\n      last = stack[stack.length - 1]\n      if (\n        last &&\n        last.name === str.split(/\\s+/)[0].replace(/^end/, '') &&\n        last.ends\n      ) {\n        switch (last.name) {\n          case 'autoescape':\n            escape = opts.autoescape\n            break\n          case 'raw':\n            inRaw = false\n            break\n        }\n        stack.pop()\n        return\n      }\n\n      if (!inRaw) {\n        utils.throwError(\n          'Unexpected end of tag \"' + str.replace(/^end/, '') + '\"',\n          line,\n          opts.filename\n        )\n      }\n    }\n\n    if (inRaw) {\n      return\n    }\n\n    chunks = str.split(/\\s+(.+)?/)\n    tagName = chunks.shift()\n\n    if (!tags.hasOwnProperty(tagName)) {\n      utils.throwError('Unexpected tag \"' + str + '\"', line, opts.filename)\n    }\n\n    lexedTokens = lexer.read(utils.strip(chunks.join(' ')))\n    parser = new TokenParser(lexedTokens, filters, false, line, opts.filename)\n    tag = tags[tagName]\n\n    /**\n     * Define custom parsing methods for your tag.\n     * @callback parse\n     *\n     * @example\n     * exports.parse = function (str, line, parser, types, options, swig) {\n     *   parser.on('start', function () {\n     *     // ...\n     *   });\n     *   parser.on(types.STRING, function (token) {\n     *     // ...\n     *   });\n     * };\n     *\n     * @param {string} str The full token string of the tag.\n     * @param {number} line The line number that this tag appears on.\n     * @param {TokenParser} parser A TokenParser instance.\n     * @param {TYPES} types Lexer token type enum.\n     * @param {TagToken[]} stack The current stack of open tags.\n     * @param {SwigOpts} options Swig Options Object.\n     * @param {object} swig The Swig instance (gives acces to loaders, parsers, etc)\n     */\n    if (!tag.parse(chunks[1], line, parser, _t, stack, opts, swig)) {\n      utils.throwError('Unexpected tag \"' + tagName + '\"', line, opts.filename)\n    }\n\n    parser.parse()\n    args = parser.out\n\n    switch (tagName) {\n      case 'autoescape':\n        escape = args[0] !== 'false' ? args[0] : false\n        break\n      case 'raw':\n        inRaw = true\n        break\n    }\n\n    /**\n     * A parsed tag token.\n     * @typedef {Object} TagToken\n     * @property {compile} [compile] Method for compiling this token.\n     * @property {array} [args] Array of arguments for the tag.\n     * @property {Token[]} [content=[]] An array of tokens that are children of this Token.\n     * @property {boolean} [ends] Whether or not this tag requires an end tag.\n     * @property {string} name The name of this tag.\n     */\n    return {\n      block: !!tags[tagName].block,\n      compile: tag.compile,\n      args: args,\n      content: [],\n      ends: tag.ends,\n      name: tagName\n    }\n  }\n\n  /**\n   * Strip the whitespace from the previous token, if it is a string.\n   * @param  {object} token Parsed token.\n   * @return {object}       If the token was a string, trailing whitespace will be stripped.\n   */\n  function stripPrevToken (token) {\n    if (typeof token === 'string') {\n      token = token.replace(/\\s*$/, '')\n    }\n    return token\n  }\n\n  /*!\n   * Loop over the source, split via the tag/var/comment regular expression splitter.\n   * Send each chunk to the appropriate parser.\n   */\n  utils.each(source.split(splitter), function (chunk) {\n    var token, lines, stripPrev, prevToken, prevChildToken\n\n    if (!chunk) {\n      return\n    }\n\n    // Is a variable?\n    if (\n      !inRaw &&\n      utils.startsWith(chunk, varOpen) &&\n      utils.endsWith(chunk, varClose)\n    ) {\n      stripPrev = varStripBefore.test(chunk)\n      stripNext = varStripAfter.test(chunk)\n      token = parseVariable(chunk.replace(varStrip, ''), line)\n      // Is a tag?\n    } else if (\n      utils.startsWith(chunk, tagOpen) &&\n      utils.endsWith(chunk, tagClose)\n    ) {\n      stripPrev = tagStripBefore.test(chunk)\n      stripNext = tagStripAfter.test(chunk)\n      token = parseTag(chunk.replace(tagStrip, ''), line)\n      if (token) {\n        if (token.name === 'extends') {\n          parent = token.args\n            .join('')\n            .replace(/^'|'$/g, '')\n            .replace(/^\"|\"$/g, '')\n        } else if (token.block && !stack.length) {\n          blocks[token.args.join('')] = token\n        }\n      }\n      if (inRaw && !token) {\n        token = chunk\n      }\n      // Is a content string?\n    } else if (\n      inRaw ||\n      (!utils.startsWith(chunk, cmtOpen) && !utils.endsWith(chunk, cmtClose))\n    ) {\n      token = stripNext ? chunk.replace(/^\\s*/, '') : chunk\n      stripNext = false\n    } else if (\n      utils.startsWith(chunk, cmtOpen) &&\n      utils.endsWith(chunk, cmtClose)\n    ) {\n      return\n    }\n\n    // Did this tag ask to strip previous whitespace? <code>{%- ... %}</code> or <code>{{- ... }}</code>\n    if (stripPrev && tokens.length) {\n      prevToken = tokens.pop()\n      if (typeof prevToken === 'string') {\n        prevToken = stripPrevToken(prevToken)\n      } else if (prevToken.content && prevToken.content.length) {\n        prevChildToken = stripPrevToken(prevToken.content.pop())\n        prevToken.content.push(prevChildToken)\n      }\n      tokens.push(prevToken)\n    }\n\n    // This was a comment, so let's just keep going.\n    if (!token) {\n      return\n    }\n\n    // If there's an open item in the stack, add this to its content.\n    if (stack.length) {\n      stack[stack.length - 1].content.push(token)\n    } else {\n      tokens.push(token)\n    }\n\n    // If the token is a tag that requires an end tag, open it on the stack.\n    if (token.name && token.ends) {\n      stack.push(token)\n    }\n\n    lines = chunk.match(/\\n/g)\n    line += lines ? lines.length : 0\n  })\n\n  return {\n    name: opts.filename,\n    parent: parent,\n    tokens: tokens,\n    blocks: blocks\n  }\n}\n\n/**\n * Compile an array of tokens.\n * @param  {Token[]} template     An array of template tokens.\n * @param  {Templates[]} parents  Array of parent templates.\n * @param  {SwigOpts} [options]   Swig options object.\n * @param  {string} [blockName]   Name of the current block context.\n * @return {string}               Partial for a compiled JavaScript method that will output a rendered template.\n */\nexports.compile = function (template, parents, options, blockName) {\n  var out = ''\n  var tokens = utils.isArray(template) ? template : template.tokens\n\n  utils.each(tokens, function (token) {\n    var o\n    if (typeof token === 'string') {\n      out +=\n        '_output += \"' +\n        token\n          .replace(/\\\\/g, '\\\\\\\\')\n          .replace(/\\n|\\r/g, '\\\\n')\n          .replace(/\"/g, '\\\\\"') +\n        '\";\\n'\n      return\n    }\n\n    /**\n     * Compile callback for VarToken and TagToken objects.\n     * @callback compile\n     *\n     * @example\n     * exports.compile = function (compiler, args, content, parents, options, blockName) {\n     *   if (args[0] === 'foo') {\n     *     return compiler(content, parents, options, blockName) + '\\n';\n     *   }\n     *   return '_output += \"fallback\";\\n';\n     * };\n     *\n     * @param {parserCompiler} compiler\n     * @param {array} [args] Array of parsed arguments on the for the token.\n     * @param {array} [content] Array of content within the token.\n     * @param {array} [parents] Array of parent templates for the current template context.\n     * @param {SwigOpts} [options] Swig Options Object\n     * @param {string} [blockName] Name of the direct block parent, if any.\n     */\n    o = token.compile(\n      exports.compile,\n      token.args ? token.args.slice(0) : [],\n      token.content ? token.content.slice(0) : [],\n      parents,\n      options,\n      blockName\n    )\n    out += o || ''\n  })\n\n  return out\n}\n\n\n//# sourceURL=webpack:///../node_modules/swig-templates/lib/parser.js?");

/***/ }),

/***/ "../node_modules/swig-templates/lib/swig.js":
/*!**************************************************!*\
  !*** ../node_modules/swig-templates/lib/swig.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var utils = __webpack_require__(/*! ./utils */ \"../node_modules/swig-templates/lib/utils.js\")\nvar _tags = __webpack_require__(/*! ./tags */ \"../node_modules/swig-templates/lib/tags/index.js\")\nvar _filters = __webpack_require__(/*! ./filters */ \"../node_modules/swig-templates/lib/filters.js\")\nvar parser = __webpack_require__(/*! ./parser */ \"../node_modules/swig-templates/lib/parser.js\")\nvar dateformatter = __webpack_require__(/*! ./dateformatter */ \"../node_modules/swig-templates/lib/dateformatter.js\")\nvar loaders = __webpack_require__(/*! ./loaders */ \"../node_modules/swig-templates/lib/loaders/index.js\")\n\n/**\n * Swig version number as a string.\n * @example\n * if (swig.version === \"1.4.2\") { ... }\n *\n * @type {String}\n */\nexports.version = '1.4.2'\n\n/**\n * Swig Options Object. This object can be passed to many of the API-level Swig methods to control various aspects of the engine. All keys are optional.\n * @typedef {Object} SwigOpts\n * @property {boolean} autoescape  Controls whether or not variable output will automatically be escaped for safe HTML output. Defaults to <code data-language=\"js\">true</code>. Functions executed in variable statements will not be auto-escaped. Your application/functions should take care of their own auto-escaping.\n * @property {array}   varControls Open and close controls for variables. Defaults to <code data-language=\"js\">['{{', '}}']</code>.\n * @property {array}   tagControls Open and close controls for tags. Defaults to <code data-language=\"js\">['{%', '%}']</code>.\n * @property {array}   cmtControls Open and close controls for comments. Defaults to <code data-language=\"js\">['{#', '#}']</code>.\n * @property {object}  locals      Default variable context to be passed to <strong>all</strong> templates.\n * @property {CacheOptions} cache Cache control for templates. Defaults to saving in <code data-language=\"js\">'memory'</code>. Send <code data-language=\"js\">false</code> to disable. Send an object with <code data-language=\"js\">get</code> and <code data-language=\"js\">set</code> functions to customize.\n * @property {TemplateLoader} loader The method that Swig will use to load templates. Defaults to <var>swig.loaders.fs</var>.\n */\nvar defaultOptions = {\n  autoescape: true,\n  varControls: ['{{', '}}'],\n  tagControls: ['{%', '%}'],\n  cmtControls: ['{#', '#}'],\n  locals: {},\n  /**\n   * Cache control for templates. Defaults to saving all templates into memory.\n   * @typedef {boolean|string|object} CacheOptions\n   * @example\n   * // Default\n   * swig.setDefaults({ cache: 'memory' });\n   * @example\n   * // Disables caching in Swig.\n   * swig.setDefaults({ cache: false });\n   * @example\n   * // Custom cache storage and retrieval\n   * swig.setDefaults({\n   *   cache: {\n   *     get: function (key) { ... },\n   *     set: function (key, val) { ... }\n   *   }\n   * });\n   */\n  cache: 'memory',\n  /**\n   * Configure Swig to use either the <var>swig.loaders.fs</var> or <var>swig.loaders.memory</var> template loader. Or, you can write your own!\n   * For more information, please see the <a href=\"../loaders/\">Template Loaders documentation</a>.\n   * @typedef {class} TemplateLoader\n   * @example\n   * // Default, FileSystem loader\n   * swig.setDefaults({ loader: swig.loaders.fs() });\n   * @example\n   * // FileSystem loader allowing a base path\n   * // With this, you don't use relative URLs in your template references\n   * swig.setDefaults({ loader: swig.loaders.fs(__dirname + '/templates') });\n   * @example\n   * // Memory Loader\n   * swig.setDefaults({ loader: swig.loaders.memory({\n   *   layout: '{% block foo %}{% endblock %}',\n   *   page1: '{% extends \"layout\" %}{% block foo %}Tacos!{% endblock %}'\n   * })});\n   */\n  loader: loaders.fs()\n}\nvar defaultInstance\n\n/**\n * Empty function, used in templates.\n * @return {string} Empty string\n * @private\n */\nfunction efn () {\n  return ''\n}\n\n/**\n * Validate the Swig options object.\n * @param  {?SwigOpts} options Swig options object.\n * @return {undefined}      This method will throw errors if anything is wrong.\n * @private\n */\nfunction validateOptions (options) {\n  if (!options) {\n    return\n  }\n\n  utils.each(['varControls', 'tagControls', 'cmtControls'], function (key) {\n    if (!options.hasOwnProperty(key)) {\n      return\n    }\n    if (!utils.isArray(options[key]) || options[key].length !== 2) {\n      throw new Error(\n        'Option \"' +\n          key +\n          '\" must be an array containing 2 different control strings.'\n      )\n    }\n    if (options[key][0] === options[key][1]) {\n      throw new Error(\n        'Option \"' + key + '\" open and close controls must not be the same.'\n      )\n    }\n    utils.each(options[key], function (a, i) {\n      if (a.length < 2) {\n        throw new Error(\n          'Option \"' +\n            key +\n            '\" ' +\n            (i ? 'open ' : 'close ') +\n            'control must be at least 2 characters. Saw \"' +\n            a +\n            '\" instead.'\n        )\n      }\n    })\n  })\n\n  if (options.hasOwnProperty('cache')) {\n    if (options.cache && options.cache !== 'memory') {\n      if (!options.cache.get || !options.cache.set) {\n        throw new Error(\n          'Invalid cache option ' +\n            JSON.stringify(options.cache) +\n            ' found. Expected \"memory\" or { get: function (key) { ... }, set: function (key, value) { ... } }.'\n        )\n      }\n    }\n  }\n  if (options.hasOwnProperty('loader')) {\n    if (options.loader) {\n      if (!options.loader.load || !options.loader.resolve) {\n        throw new Error(\n          'Invalid loader option ' +\n            JSON.stringify(options.loader) +\n            ' found. Expected { load: function (pathname, cb) { ... }, resolve: function (to, from) { ... } }.'\n        )\n      }\n    }\n  }\n}\n\n/**\n * Set defaults for the base and all new Swig environments.\n *\n * @example\n * swig.setDefaults({ cache: false });\n * // => Disables Cache\n *\n * @example\n * swig.setDefaults({ locals: { now: function () { return new Date(); } }});\n * // => sets a globally accessible method for all template\n * //    contexts, allowing you to print the current date\n * // => {{ now()|date('F jS, Y') }}\n *\n * @param  {SwigOpts} [options={}] Swig options object.\n * @return {undefined}\n */\nexports.setDefaults = function (options) {\n  validateOptions(options)\n  defaultInstance.options = utils.extend(defaultInstance.options, options)\n}\n\n/**\n * Set the default TimeZone offset for date formatting via the date filter. This is a global setting and will affect all Swig environments, old or new.\n * @param  {number} offset Offset from GMT, in minutes.\n * @return {undefined}\n */\nexports.setDefaultTZOffset = function (offset) {\n  dateformatter.tzOffset = offset\n}\n\n/**\n * Create a new, separate Swig compile/render environment.\n *\n * @example\n * var swig = require('swig');\n * var myswig = new swig.Swig({varControls: ['<%=', '%>']});\n * myswig.render('Tacos are <%= tacos =>!', { locals: { tacos: 'delicious' }});\n * // => Tacos are delicious!\n * swig.render('Tacos are <%= tacos =>!', { locals: { tacos: 'delicious' }});\n * // => 'Tacos are <%= tacos =>!'\n *\n * @param  {SwigOpts} [opts={}] Swig options object.\n * @return {object}      New Swig environment.\n */\nexports.Swig = function (opts) {\n  validateOptions(opts)\n  this.options = utils.extend({}, defaultOptions, opts || {})\n  this.cache = {}\n  this.extensions = {}\n  var self = this\n  var tags = _tags\n  var filters = _filters\n\n  /**\n   * Get combined locals context.\n   * @param  {?SwigOpts} [options] Swig options object.\n   * @return {object}         Locals context.\n   * @private\n   */\n  function getLocals (options) {\n    if (!options || !options.locals) {\n      return self.options.locals\n    }\n\n    return utils.extend({}, self.options.locals, options.locals)\n  }\n\n  /**\n   * Determine whether caching is enabled via the options provided and/or defaults\n   * @param  {SwigOpts} [options={}] Swig Options Object\n   * @return {boolean}\n   * @private\n   */\n  function shouldCache (options) {\n    options = options || {}\n    return (\n      (options.hasOwnProperty('cache') && !options.cache) || !self.options.cache\n    )\n  }\n\n  /**\n   * Get compiled template from the cache.\n   * @param  {string} key           Name of template.\n   * @return {object|undefined}     Template function and tokens.\n   * @private\n   */\n  function cacheGet (key, options) {\n    if (shouldCache(options)) {\n      return\n    }\n\n    if (self.options.cache === 'memory') {\n      return self.cache[key]\n    }\n\n    return self.options.cache.get(key)\n  }\n\n  /**\n   * Store a template in the cache.\n   * @param  {string} key Name of template.\n   * @param  {object} val Template function and tokens.\n   * @return {undefined}\n   * @private\n   */\n  function cacheSet (key, options, val) {\n    if (shouldCache(options)) {\n      return\n    }\n\n    if (self.options.cache === 'memory') {\n      self.cache[key] = val\n      return\n    }\n\n    self.options.cache.set(key, val)\n  }\n\n  /**\n   * Clears the in-memory template cache.\n   *\n   * @example\n   * swig.invalidateCache();\n   *\n   * @return {undefined}\n   */\n  this.invalidateCache = function () {\n    if (self.options.cache === 'memory') {\n      self.cache = {}\n    }\n  }\n\n  /**\n   * Add a custom filter for swig variables.\n   *\n   * @example\n   * function replaceMs(input) { return input.replace(/m/g, 'f'); }\n   * swig.setFilter('replaceMs', replaceMs);\n   * // => {{ \"onomatopoeia\"|replaceMs }}\n   * // => onofatopeia\n   *\n   * @param {string}    name    Name of filter, used in templates. <strong>Will</strong> overwrite previously defined filters, if using the same name.\n   * @param {function}  method  Function that acts against the input. See <a href=\"/docs/filters/#custom\">Custom Filters</a> for more information.\n   * @return {undefined}\n   */\n  this.setFilter = function (name, method) {\n    if (typeof method !== 'function') {\n      throw new Error('Filter \"' + name + '\" is not a valid function.')\n    }\n    filters[name] = method\n  }\n\n  /**\n   * Add a custom tag. To expose your own extensions to compiled template code, see <code data-language=\"js\">swig.setExtension</code>.\n   *\n   * For a more in-depth explanation of writing custom tags, see <a href=\"../extending/#tags\">Custom Tags</a>.\n   *\n   * @example\n   * var tacotag = require('./tacotag');\n   * swig.setTag('tacos', tacotag.parse, tacotag.compile, tacotag.ends, tacotag.blockLevel);\n   * // => {% tacos %}Make this be tacos.{% endtacos %}\n   * // => Tacos tacos tacos tacos.\n   *\n   * @param  {string} name      Tag name.\n   * @param  {function} parse   Method for parsing tokens.\n   * @param  {function} compile Method for compiling renderable output.\n   * @param  {boolean} [ends=false]     Whether or not this tag requires an <i>end</i> tag.\n   * @param  {boolean} [blockLevel=false] If false, this tag will not be compiled outside of <code>block</code> tags when extending a parent template.\n   * @return {undefined}\n   */\n  this.setTag = function (name, parse, compile, ends, blockLevel) {\n    if (typeof parse !== 'function') {\n      throw new Error(\n        'Tag \"' + name + '\" parse method is not a valid function.'\n      )\n    }\n\n    if (typeof compile !== 'function') {\n      throw new Error(\n        'Tag \"' + name + '\" compile method is not a valid function.'\n      )\n    }\n\n    tags[name] = {\n      parse: parse,\n      compile: compile,\n      ends: ends || false,\n      block: !!blockLevel\n    }\n  }\n\n  /**\n   * Add extensions for custom tags. This allows any custom tag to access a globally available methods via a special globally available object, <var>_ext</var>, in templates.\n   *\n   * @example\n   * swig.setExtension('trans', function (v) { return translate(v); });\n   * function compileTrans(compiler, args, content, parent, options) {\n   *   return '_output += _ext.trans(' + args[0] + ');'\n   * };\n   * swig.setTag('trans', parseTrans, compileTrans, true);\n   *\n   * @param  {string} name   Key name of the extension. Accessed via <code data-language=\"js\">_ext[name]</code>.\n   * @param  {*}      object The method, value, or object that should be available via the given name.\n   * @return {undefined}\n   */\n  this.setExtension = function (name, object) {\n    self.extensions[name] = object\n  }\n\n  /**\n   * Parse a given source string into tokens.\n   *\n   * @param  {string} source  Swig template source.\n   * @param  {SwigOpts} [options={}] Swig options object.\n   * @return {object} parsed  Template tokens object.\n   * @private\n   */\n  this.parse = function (source, options) {\n    validateOptions(options)\n\n    var locals = getLocals(options)\n    var opt = {}\n    var k\n\n    for (k in options) {\n      if (options.hasOwnProperty(k) && k !== 'locals') {\n        opt[k] = options[k]\n      }\n    }\n\n    options = utils.extend({}, self.options, opt)\n    options.locals = locals\n\n    return parser.parse(this, source, options, tags, filters)\n  }\n\n  /**\n   * Parse a given file into tokens.\n   *\n   * @param  {string} pathname  Full path to file to parse.\n   * @param  {SwigOpts} [options={}]   Swig options object.\n   * @return {object} parsed    Template tokens object.\n   * @private\n   */\n  this.parseFile = function (pathname, options) {\n    var src\n\n    if (!options) {\n      options = {}\n    }\n\n    pathname = self.options.loader.resolve(pathname, options.resolveFrom)\n\n    src = self.options.loader.load(pathname)\n\n    if (!options.filename) {\n      options = utils.extend({ filename: pathname }, options)\n    }\n\n    return self.parse(src, options)\n  }\n\n  /**\n   * Re-Map blocks within a list of tokens to the template's block objects.\n   * @param  {array}  tokens   List of tokens for the parent object.\n   * @param  {object} template Current template that needs to be mapped to the  parent's block and token list.\n   * @return {array}\n   * @private\n   */\n  function remapBlocks (blocks, tokens) {\n    return utils.map(tokens, function (token) {\n      var args = token.args ? token.args.join('') : ''\n      if (token.name === 'block' && blocks[args]) {\n        token = blocks[args]\n      }\n      if (token.content && token.content.length) {\n        token.content = remapBlocks(blocks, token.content)\n      }\n      return token\n    })\n  }\n\n  /**\n   * Import block-level tags to the token list that are not actual block tags.\n   * @param  {array} blocks List of block-level tags.\n   * @param  {array} tokens List of tokens to render.\n   * @return {undefined}\n   * @private\n   */\n  function importNonBlocks (blocks, tokens) {\n    var temp = []\n    utils.each(blocks, function (block) {\n      temp.push(block)\n    })\n    utils.each(temp.reverse(), function (block) {\n      if (block.name !== 'block') {\n        tokens.unshift(block)\n      }\n    })\n  }\n\n  /**\n   * Recursively compile and get parents of given parsed token object.\n   *\n   * @param  {object} tokens    Parsed tokens from template.\n   * @param  {SwigOpts} [options={}]   Swig options object.\n   * @return {object}           Parsed tokens from parent templates.\n   * @private\n   */\n  function getParents (tokens, options) {\n    var parentName = tokens.parent\n    var parentFiles = []\n    var parents = []\n    var parentFile\n    var parent\n    var l\n\n    while (parentName) {\n      if (!options || !options.filename) {\n        throw new Error(\n          'Cannot extend \"' +\n            parentName +\n            '\" because current template has no filename.'\n        )\n      }\n\n      parentFile = parentFile || options.filename\n      parentFile = self.options.loader.resolve(parentName, parentFile)\n      parent =\n        cacheGet(parentFile, options) ||\n        self.parseFile(\n          parentFile,\n          utils.extend({}, options, { filename: parentFile })\n        )\n      parentName = parent.parent\n\n      if (parentFiles.indexOf(parentFile) !== -1) {\n        throw new Error('Illegal circular extends of \"' + parentFile + '\".')\n      }\n      parentFiles.push(parentFile)\n\n      parents.push(parent)\n    }\n\n    // Remap each parents'(1) blocks onto its own parent(2), receiving the full token list for rendering the original parent(1) on its own.\n    l = parents.length\n    for (l = parents.length - 2; l >= 0; l -= 1) {\n      parents[l].tokens = remapBlocks(parents[l].blocks, parents[l + 1].tokens)\n      importNonBlocks(parents[l].blocks, parents[l].tokens)\n    }\n\n    return parents\n  }\n\n  /**\n   * Pre-compile a source string into a cache-able template function.\n   *\n   * @example\n   * swig.precompile('{{ tacos }}');\n   * // => {\n   * //      tpl: function (_swig, _locals, _filters, _utils, _fn) { ... },\n   * //      tokens: {\n   * //        name: undefined,\n   * //        parent: null,\n   * //        tokens: [...],\n   * //        blocks: {}\n   * //      }\n   * //    }\n   *\n   * In order to render a pre-compiled template, you must have access to filters and utils from Swig. <var>efn</var> is simply an empty function that does nothing.\n   *\n   * @param  {string} source  Swig template source string.\n   * @param  {SwigOpts} [options={}] Swig options object.\n   * @return {object}         Renderable function and tokens object.\n   */\n  this.precompile = function (source, options) {\n    var tokens = self.parse(source, options)\n    var parents = getParents(tokens, options)\n    var tpl\n\n    if (parents.length) {\n      // Remap the templates first-parent's tokens using this template's blocks.\n      tokens.tokens = remapBlocks(tokens.blocks, parents[0].tokens)\n      importNonBlocks(tokens.blocks, tokens.tokens)\n    }\n\n    try {\n      tpl = new Function( // eslint-disable-line\n        '_swig',\n        '_ctx',\n        '_filters',\n        '_utils',\n        '_fn',\n        '  var _ext = _swig.extensions,\\n' +\n          '    _output = \"\";\\n' +\n          parser.compile(tokens, parents, options) +\n          '\\n' +\n          '  return _output;\\n'\n      )\n    } catch (e) {\n      utils.throwError(e, null, options.filename)\n    }\n\n    return { tpl: tpl, tokens: tokens }\n  }\n\n  /**\n   * Compile and render a template string for final output.\n   *\n   * When rendering a source string, a file path should be specified in the options object in order for <var>extends</var>, <var>include</var>, and <var>import</var> to work properly. Do this by adding <code data-language=\"js\">{ filename: '/absolute/path/to/mytpl.html' }</code> to the options argument.\n   *\n   * @example\n   * swig.render('{{ tacos }}', { locals: { tacos: 'Tacos!!!!' }});\n   * // => Tacos!!!!\n   *\n   * @param  {string} source    Swig template source string.\n   * @param  {SwigOpts} [options={}] Swig options object.\n   * @return {string}           Rendered output.\n   */\n  this.render = function (source, options) {\n    return self.compile(source, options)()\n  }\n\n  /**\n   * Compile and render a template file for final output. This is most useful for libraries like Express.js.\n   *\n   * @example\n   * swig.renderFile('./template.html', {}, function (err, output) {\n   *   if (err) {\n   *     throw err;\n   *   }\n   *   console.log(output);\n   * });\n   *\n   * @example\n   * swig.renderFile('./template.html', {});\n   * // => output\n   *\n   * @param  {string}   pathName    File location.\n   * @param  {object}   [locals={}] Template variable context.\n   * @param  {Function} [cb] Asyncronous callback function. If not provided, <var>compileFile</var> will run syncronously.\n   * @return {string}             Rendered output.\n   */\n  this.renderFile = function (pathName, locals, cb) {\n    if (cb) {\n      self.compileFile(pathName, {}, function (err, fn) {\n        var result\n\n        if (err) {\n          cb(err)\n          return\n        }\n\n        try {\n          result = fn(locals)\n        } catch (err2) {\n          cb(err2)\n          return\n        }\n\n        cb(null, result)\n      })\n      return\n    }\n\n    return self.compileFile(pathName)(locals)\n  }\n\n  /**\n   * Compile string source into a renderable template function.\n   *\n   * @example\n   * var tpl = swig.compile('{{ tacos }}');\n   * // => {\n   * //      [Function: compiled]\n   * //      parent: null,\n   * //      tokens: [{ compile: [Function] }],\n   * //      blocks: {}\n   * //    }\n   * tpl({ tacos: 'Tacos!!!!' });\n   * // => Tacos!!!!\n   *\n   * When compiling a source string, a file path should be specified in the options object in order for <var>extends</var>, <var>include</var>, and <var>import</var> to work properly. Do this by adding <code data-language=\"js\">{ filename: '/absolute/path/to/mytpl.html' }</code> to the options argument.\n   *\n   * @param  {string} source    Swig template source string.\n   * @param  {SwigOpts} [options={}] Swig options object.\n   * @return {function}         Renderable function with keys for parent, blocks, and tokens.\n   */\n  this.compile = function (source, options) {\n    var key = options ? options.filename : null\n    var cached = key ? cacheGet(key, options) : null\n    var context\n    var contextLength\n    var pre\n\n    if (cached) {\n      return cached\n    }\n\n    context = getLocals(options)\n    contextLength = utils.keys(context).length\n    pre = self.precompile(source, options)\n\n    function compiled (locals) {\n      var lcls\n      if (locals && contextLength) {\n        lcls = utils.extend({}, context, locals)\n      } else if (locals && !contextLength) {\n        lcls = locals\n      } else if (!locals && contextLength) {\n        lcls = context\n      } else {\n        lcls = {}\n      }\n      return pre.tpl(self, lcls, filters, utils, efn)\n    }\n\n    utils.extend(compiled, pre.tokens)\n\n    if (key) {\n      cacheSet(key, options, compiled)\n    }\n\n    return compiled\n  }\n\n  /**\n   * Compile a source file into a renderable template function.\n   *\n   * @example\n   * var tpl = swig.compileFile('./mytpl.html');\n   * // => {\n   * //      [Function: compiled]\n   * //      parent: null,\n   * //      tokens: [{ compile: [Function] }],\n   * //      blocks: {}\n   * //    }\n   * tpl({ tacos: 'Tacos!!!!' });\n   * // => Tacos!!!!\n   *\n   * @example\n   * swig.compileFile('/myfile.txt', { varControls: ['<%=', '=%>'], tagControls: ['<%', '%>']});\n   * // => will compile 'myfile.txt' using the var and tag controls as specified.\n   *\n   * @param  {string} pathname  File location.\n   * @param  {SwigOpts} [options={}] Swig options object.\n   * @param  {Function} [cb] Asyncronous callback function. If not provided, <var>compileFile</var> will run syncronously.\n   * @return {function}         Renderable function with keys for parent, blocks, and tokens.\n   */\n  this.compileFile = function (pathname, options, cb) {\n    var src, cached\n\n    if (!options) {\n      options = {}\n    }\n\n    pathname = self.options.loader.resolve(pathname, options.resolveFrom)\n    if (!options.filename) {\n      options = utils.extend({ filename: pathname }, options)\n    }\n    cached = cacheGet(pathname, options)\n\n    if (cached) {\n      if (cb) {\n        cb(null, cached)\n        return\n      }\n      return cached\n    }\n\n    if (cb) {\n      self.options.loader.load(pathname, function (err, src) {\n        if (err) {\n          cb(err)\n          return\n        }\n        var compiled\n\n        try {\n          compiled = self.compile(src, options)\n        } catch (err2) {\n          cb(err2)\n          return\n        }\n\n        cb(err, compiled)\n      })\n      return\n    }\n\n    src = self.options.loader.load(pathname)\n    return self.compile(src, options)\n  }\n\n  /**\n   * Run a pre-compiled template function. This is most useful in the browser when you've pre-compiled your templates with the Swig command-line tool.\n   *\n   * @example\n   * $ swig compile ./mytpl.html --wrap-start=\"var mytpl = \" > mytpl.js\n   * @example\n   * <script src=\"mytpl.js\"></script>\n   * <script>\n   *   swig.run(mytpl, {});\n   *   // => \"rendered template...\"\n   * </script>\n   *\n   * @param  {function} tpl       Pre-compiled Swig template function. Use the Swig CLI to compile your templates.\n   * @param  {object} [locals={}] Template variable context.\n   * @param  {string} [filepath]  Filename used for caching the template.\n   * @return {string}             Rendered output.\n   */\n  this.run = function (tpl, locals, filepath) {\n    var context = getLocals({ locals: locals })\n    if (filepath) {\n      cacheSet(filepath, {}, tpl)\n    }\n    return tpl(self, context, filters, utils, efn)\n  }\n}\n\n/*!\n * Export methods publicly\n */\ndefaultInstance = new exports.Swig()\nexports.setFilter = defaultInstance.setFilter\nexports.setTag = defaultInstance.setTag\nexports.setExtension = defaultInstance.setExtension\nexports.parseFile = defaultInstance.parseFile\nexports.precompile = defaultInstance.precompile\nexports.compile = defaultInstance.compile\nexports.compileFile = defaultInstance.compileFile\nexports.render = defaultInstance.render\nexports.renderFile = defaultInstance.renderFile\nexports.run = defaultInstance.run\nexports.invalidateCache = defaultInstance.invalidateCache\nexports.loaders = loaders\n\n\n//# sourceURL=webpack:///../node_modules/swig-templates/lib/swig.js?");

/***/ }),

/***/ "../node_modules/swig-templates/lib/tags/autoescape.js":
/*!*************************************************************!*\
  !*** ../node_modules/swig-templates/lib/tags/autoescape.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var utils = __webpack_require__(/*! ../utils */ \"../node_modules/swig-templates/lib/utils.js\")\nvar strings = ['html', 'js']\n\n/**\n * Control auto-escaping of variable output from within your templates.\n *\n * @alias autoescape\n *\n * @example\n * // myvar = '<foo>';\n * {% autoescape true %}{{ myvar }}{% endautoescape %}\n * // => &lt;foo&gt;\n * {% autoescape false %}{{ myvar }}{% endautoescape %}\n * // => <foo>\n *\n * @param {boolean|string} control One of `true`, `false`, `\"js\"` or `\"html\"`.\n */\nexports.compile = function (\n  compiler,\n  args,\n  content,\n  parents,\n  options,\n  blockName\n) {\n  return compiler(content, parents, options, blockName)\n}\nexports.parse = function (str, line, parser, types, stack, opts) {\n  var matched\n  parser.on('*', function (token) {\n    if (\n      !matched &&\n      (token.type === types.BOOL ||\n        (token.type === types.STRING && strings.indexOf(token.match) === -1))\n    ) {\n      this.out.push(token.match)\n      matched = true\n      return\n    }\n    utils.throwError(\n      'Unexpected token \"' + token.match + '\" in autoescape tag',\n      line,\n      opts.filename\n    )\n  })\n\n  return true\n}\nexports.ends = true\n\n\n//# sourceURL=webpack:///../node_modules/swig-templates/lib/tags/autoescape.js?");

/***/ }),

/***/ "../node_modules/swig-templates/lib/tags/block.js":
/*!********************************************************!*\
  !*** ../node_modules/swig-templates/lib/tags/block.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Defines a block in a template that can be overridden by a template extending this one and/or will override the current template's parent template block of the same name.\n *\n * See <a href=\"#inheritance\">Template Inheritance</a> for more information.\n *\n * @alias block\n *\n * @example\n * {% block body %}...{% endblock %}\n *\n * @param {literal}  name   Name of the block for use in parent and extended templates.\n */\nexports.compile = function (compiler, args, content, parents, options) {\n  return compiler(content, parents, options, args.join(''))\n}\n\nexports.parse = function (str, line, parser) {\n  parser.on('*', function (token) {\n    this.out.push(token.match)\n  })\n  return true\n}\n\nexports.ends = true\nexports.block = true\n\n\n//# sourceURL=webpack:///../node_modules/swig-templates/lib/tags/block.js?");

/***/ }),

/***/ "../node_modules/swig-templates/lib/tags/else.js":
/*!*******************************************************!*\
  !*** ../node_modules/swig-templates/lib/tags/else.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Used within an <code data-language=\"swig\">{% if %}</code> tag, the code block following this tag up until <code data-language=\"swig\">{% endif %}</code> will be rendered if the <i>if</i> statement returns false.\n *\n * @alias else\n *\n * @example\n * {% if false %}\n *   statement1\n * {% else %}\n *   statement2\n * {% endif %}\n * // => statement2\n *\n */\nexports.compile = function () {\n  return '} else {\\n'\n}\n\nexports.parse = function (str, line, parser, types, stack) {\n  parser.on('*', function (token) {\n    throw new Error(\n      '\"else\" tag does not accept any tokens. Found \"' +\n        token.match +\n        '\" on line ' +\n        line +\n        '.'\n    )\n  })\n\n  return stack.length && stack[stack.length - 1].name === 'if'\n}\n\n\n//# sourceURL=webpack:///../node_modules/swig-templates/lib/tags/else.js?");

/***/ }),

/***/ "../node_modules/swig-templates/lib/tags/elseif.js":
/*!*********************************************************!*\
  !*** ../node_modules/swig-templates/lib/tags/elseif.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var ifparser = __webpack_require__(/*! ./if */ \"../node_modules/swig-templates/lib/tags/if.js\").parse\n\n/**\n * Like <code data-language=\"swig\">{% else %}</code>, except this tag can take more conditional statements.\n *\n * @alias elseif\n * @alias elif\n *\n * @example\n * {% if false %}\n *   Tacos\n * {% elseif true %}\n *   Burritos\n * {% else %}\n *   Churros\n * {% endif %}\n * // => Burritos\n *\n * @param {...mixed} conditional  Conditional statement that returns a truthy or falsy value.\n */\nexports.compile = function (compiler, args) {\n  return '} else if (' + args.join(' ') + ') {\\n'\n}\n\nexports.parse = function (str, line, parser, types, stack) {\n  var okay = ifparser(str, line, parser, types, stack)\n  return okay && (stack.length && stack[stack.length - 1].name === 'if')\n}\n\n\n//# sourceURL=webpack:///../node_modules/swig-templates/lib/tags/elseif.js?");

/***/ }),

/***/ "../node_modules/swig-templates/lib/tags/extends.js":
/*!**********************************************************!*\
  !*** ../node_modules/swig-templates/lib/tags/extends.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Makes the current template extend a parent template. This tag must be the first item in your template.\n *\n * See <a href=\"#inheritance\">Template Inheritance</a> for more information.\n *\n * @alias extends\n *\n * @example\n * {% extends \"./layout.html\" %}\n *\n * @param {string} parentFile  Relative path to the file that this template extends.\n */\nexports.compile = function () {}\n\nexports.parse = function () {\n  return true\n}\n\nexports.ends = false\n\n\n//# sourceURL=webpack:///../node_modules/swig-templates/lib/tags/extends.js?");

/***/ }),

/***/ "../node_modules/swig-templates/lib/tags/filter.js":
/*!*********************************************************!*\
  !*** ../node_modules/swig-templates/lib/tags/filter.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var filters = __webpack_require__(/*! ../filters */ \"../node_modules/swig-templates/lib/filters.js\")\n\n/**\n * Apply a filter to an entire block of template.\n *\n * @alias filter\n *\n * @example\n * {% filter uppercase %}oh hi, {{ name }}{% endfilter %}\n * // => OH HI, PAUL\n *\n * @example\n * {% filter replace(\".\", \"!\", \"g\") %}Hi. My name is Paul.{% endfilter %}\n * // => Hi! My name is Paul!\n *\n * @param {function} filter  The filter that should be applied to the contents of the tag.\n */\n\nexports.compile = function (\n  compiler,\n  args,\n  content,\n  parents,\n  options,\n  blockName\n) {\n  var filter = args.shift().replace(/\\($/, '')\n  var val =\n    '(function () {\\n' +\n    '  var _output = \"\";\\n' +\n    compiler(content, parents, options, blockName) +\n    '  return _output;\\n' +\n    '})()'\n\n  if (args[args.length - 1] === ')') {\n    args.pop()\n  }\n\n  args = args.length ? ', ' + args.join('') : ''\n  return '_output += _filters[\"' + filter + '\"](' + val + args + ');\\n'\n}\n\nexports.parse = function (str, line, parser, types) {\n  var filter\n\n  function check (filter) {\n    if (!filters.hasOwnProperty(filter)) {\n      throw new Error(\n        'Filter \"' + filter + '\" does not exist on line ' + line + '.'\n      )\n    }\n  }\n\n  parser.on(types.FUNCTION, function (token) {\n    if (!filter) {\n      filter = token.match.replace(/\\($/, '')\n      check(filter)\n      this.out.push(token.match)\n      this.state.push(token.type)\n      return\n    }\n    return true\n  })\n\n  parser.on(types.VAR, function (token) {\n    if (!filter) {\n      filter = token.match\n      check(filter)\n      this.out.push(filter)\n      return\n    }\n    return true\n  })\n\n  return true\n}\n\nexports.ends = true\n\n\n//# sourceURL=webpack:///../node_modules/swig-templates/lib/tags/filter.js?");

/***/ }),

/***/ "../node_modules/swig-templates/lib/tags/for.js":
/*!******************************************************!*\
  !*** ../node_modules/swig-templates/lib/tags/for.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var ctx = '_ctx.'\nvar ctxloop = ctx + 'loop'\n\n/**\n * Loop over objects and arrays.\n *\n * @alias for\n *\n * @example\n * // obj = { one: 'hi', two: 'bye' };\n * {% for x in obj %}\n *   {% if loop.first %}<ul>{% endif %}\n *   <li>{{ loop.index }} - {{ loop.key }}: {{ x }}</li>\n *   {% if loop.last %}</ul>{% endif %}\n * {% endfor %}\n * // => <ul>\n * //    <li>1 - one: hi</li>\n * //    <li>2 - two: bye</li>\n * //    </ul>\n *\n * @example\n * // arr = [1, 2, 3]\n * // Reverse the array, shortcut the key/index to `key`\n * {% for key, val in arr|reverse %}\n * {{ key }} -- {{ val }}\n * {% endfor %}\n * // => 0 -- 3\n * //    1 -- 2\n * //    2 -- 1\n *\n * @param {literal} [key]     A shortcut to the index of the array or current key accessor.\n * @param {literal} variable  The current value will be assigned to this variable name temporarily. The variable will be reset upon ending the for tag.\n * @param {literal} in        Literally, \"in\". This token is required.\n * @param {object}  object    An enumerable object that will be iterated over.\n *\n * @return {loop.index} The current iteration of the loop (1-indexed)\n * @return {loop.index0} The current iteration of the loop (0-indexed)\n * @return {loop.revindex} The number of iterations from the end of the loop (1-indexed)\n * @return {loop.revindex0} The number of iterations from the end of the loop (0-indexed)\n * @return {loop.key} If the iterator is an object, this will be the key of the current item, otherwise it will be the same as the loop.index.\n * @return {loop.first} True if the current object is the first in the object or array.\n * @return {loop.last} True if the current object is the last in the object or array.\n */\nexports.compile = function (\n  compiler,\n  args,\n  content,\n  parents,\n  options,\n  blockName\n) {\n  var val = args.shift()\n  var key = '__k'\n  var ctxloopcache = (ctx + '__loopcache' + Math.random()).replace(/\\./g, '')\n  var last\n\n  if (args[0] && args[0] === ',') {\n    args.shift()\n    key = val\n    val = args.shift()\n  }\n\n  last = args.join('')\n\n  return [\n    '(function () {\\n',\n    '  var __l = ' +\n      last +\n      ', __len = (_utils.isArray(__l) || typeof __l === \"string\") ? __l.length : _utils.keys(__l).length;\\n',\n    '  if (!__l) { return; }\\n',\n    '    var ' +\n      ctxloopcache +\n      ' = { loop: ' +\n      ctxloop +\n      ', ' +\n      val +\n      ': ' +\n      ctx +\n      val +\n      ', ' +\n      key +\n      ': ' +\n      ctx +\n      key +\n      ' };\\n',\n    '    ' +\n      ctxloop +\n      ' = { first: false, index: 1, index0: 0, revindex: __len, revindex0: __len - 1, length: __len, last: false };\\n',\n    '  _utils.each(__l, function (' + val + ', ' + key + ') {\\n',\n    '    ' + ctx + val + ' = ' + val + ';\\n',\n    '    ' + ctx + key + ' = ' + key + ';\\n',\n    '    ' + ctxloop + '.key = ' + key + ';\\n',\n    '    ' + ctxloop + '.first = (' + ctxloop + '.index0 === 0);\\n',\n    '    ' + ctxloop + '.last = (' + ctxloop + '.revindex0 === 0);\\n',\n    '    ' + compiler(content, parents, options, blockName),\n    '    ' +\n      ctxloop +\n      '.index += 1; ' +\n      ctxloop +\n      '.index0 += 1; ' +\n      ctxloop +\n      '.revindex -= 1; ' +\n      ctxloop +\n      '.revindex0 -= 1;\\n',\n    '  });\\n',\n    '  ' + ctxloop + ' = ' + ctxloopcache + '.loop;\\n',\n    '  ' + ctx + val + ' = ' + ctxloopcache + '.' + val + ';\\n',\n    '  ' + ctx + key + ' = ' + ctxloopcache + '.' + key + ';\\n',\n    '  ' + ctxloopcache + ' = undefined;\\n',\n    '})();\\n'\n  ].join('')\n}\n\nexports.parse = function (str, line, parser, types) {\n  var firstVar, ready\n\n  parser.on(types.NUMBER, function (token) {\n    var lastState = this.state.length ? this.state[this.state.length - 1] : null\n    if (\n      !ready ||\n      (lastState !== types.ARRAYOPEN &&\n        lastState !== types.CURLYOPEN &&\n        lastState !== types.CURLYCLOSE &&\n        lastState !== types.FUNCTION &&\n        lastState !== types.FILTER)\n    ) {\n      throw new Error(\n        'Unexpected number \"' + token.match + '\" on line ' + line + '.'\n      )\n    }\n    return true\n  })\n\n  parser.on(types.VAR, function (token) {\n    if (ready && firstVar) {\n      return true\n    }\n\n    if (!this.out.length) {\n      firstVar = true\n    }\n\n    this.out.push(token.match)\n  })\n\n  parser.on(types.COMMA, function (token) {\n    if (firstVar && this.prevToken.type === types.VAR) {\n      this.out.push(token.match)\n      return\n    }\n\n    return true\n  })\n\n  parser.on(types.COMPARATOR, function (token) {\n    if (token.match !== 'in' || !firstVar) {\n      throw new Error(\n        'Unexpected token \"' + token.match + '\" on line ' + line + '.'\n      )\n    }\n    ready = true\n    this.filterApplyIdx.push(this.out.length)\n  })\n\n  return true\n}\n\nexports.ends = true\n\n\n//# sourceURL=webpack:///../node_modules/swig-templates/lib/tags/for.js?");

/***/ }),

/***/ "../node_modules/swig-templates/lib/tags/if.js":
/*!*****************************************************!*\
  !*** ../node_modules/swig-templates/lib/tags/if.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Used to create conditional statements in templates. Accepts most JavaScript valid comparisons.\n *\n * Can be used in conjunction with <a href=\"#elseif\"><code data-language=\"swig\">{% elseif ... %}</code></a> and <a href=\"#else\"><code data-language=\"swig\">{% else %}</code></a> tags.\n *\n * @alias if\n *\n * @example\n * {% if x %}{% endif %}\n * {% if !x %}{% endif %}\n * {% if not x %}{% endif %}\n *\n * @example\n * {% if x and y %}{% endif %}\n * {% if x && y %}{% endif %}\n * {% if x or y %}{% endif %}\n * {% if x || y %}{% endif %}\n * {% if x || (y && z) %}{% endif %}\n *\n * @example\n * {% if x [operator] y %}\n *   Operators: ==, !=, <, <=, >, >=, ===, !==\n * {% endif %}\n *\n * @example\n * {% if x == 'five' %}\n *   The operands can be also be string or number literals\n * {% endif %}\n *\n * @example\n * {% if x|lower === 'tacos' %}\n *   You can use filters on any operand in the statement.\n * {% endif %}\n *\n * @example\n * {% if x in y %}\n *   If x is a value that is present in y, this will return true.\n * {% endif %}\n *\n * @param {...mixed} conditional Conditional statement that returns a truthy or falsy value.\n */\nexports.compile = function (\n  compiler,\n  args,\n  content,\n  parents,\n  options,\n  blockName\n) {\n  return (\n    'if (' +\n    args.join(' ') +\n    ') { \\n' +\n    compiler(content, parents, options, blockName) +\n    '\\n' +\n    '}'\n  )\n}\n\nexports.parse = function (str, line, parser, types) {\n  if (str === undefined) {\n    throw new Error('No conditional statement provided on line ' + line + '.')\n  }\n\n  parser.on(types.COMPARATOR, function (token) {\n    if (this.isLast) {\n      throw new Error(\n        'Unexpected logic \"' + token.match + '\" on line ' + line + '.'\n      )\n    }\n    if (this.prevToken.type === types.NOT) {\n      throw new Error(\n        'Attempted logic \"not ' +\n          token.match +\n          '\" on line ' +\n          line +\n          '. Use !(foo ' +\n          token.match +\n          ') instead.'\n      )\n    }\n    this.out.push(token.match)\n    this.filterApplyIdx.push(this.out.length)\n  })\n\n  parser.on(types.NOT, function (token) {\n    if (this.isLast) {\n      throw new Error(\n        'Unexpected logic \"' + token.match + '\" on line ' + line + '.'\n      )\n    }\n    this.out.push(token.match)\n  })\n\n  parser.on(types.BOOL, function (token) {\n    this.out.push(token.match)\n  })\n\n  parser.on(types.LOGIC, function (token) {\n    if (!this.out.length || this.isLast) {\n      throw new Error(\n        'Unexpected logic \"' + token.match + '\" on line ' + line + '.'\n      )\n    }\n    this.out.push(token.match)\n    this.filterApplyIdx.pop()\n  })\n\n  return true\n}\n\nexports.ends = true\n\n\n//# sourceURL=webpack:///../node_modules/swig-templates/lib/tags/if.js?");

/***/ }),

/***/ "../node_modules/swig-templates/lib/tags/import.js":
/*!*********************************************************!*\
  !*** ../node_modules/swig-templates/lib/tags/import.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var utils = __webpack_require__(/*! ../utils */ \"../node_modules/swig-templates/lib/utils.js\")\n\n/**\n * Allows you to import macros from another file directly into your current context.\n * The import tag is specifically designed for importing macros into your template with a specific context scope. This is very useful for keeping your macros from overriding template context that is being injected by your server-side page generation.\n *\n * @alias import\n *\n * @example\n * {% import './formmacros.html' as form %}\n * {{ form.input(\"text\", \"name\") }}\n * // => <input type=\"text\" name=\"name\">\n *\n * @example\n * {% import \"../shared/tags.html\" as tags %}\n * {{ tags.stylesheet('global') }}\n * // => <link rel=\"stylesheet\" href=\"/global.css\">\n *\n * @param {string|var}  file      Relative path from the current template file to the file to import macros from.\n * @param {literal}     as        Literally, \"as\".\n * @param {literal}     varname   Local-accessible object name to assign the macros to.\n */\nexports.compile = function (compiler, args) {\n  var ctx = args.pop()\n  var allMacros = utils\n    .map(args, function (arg) {\n      return arg.name\n    })\n    .join('|')\n  var out = '_ctx.' + ctx + ' = {};\\n  var _output = \"\";\\n'\n  var replacements = utils.map(args, function (arg) {\n    return {\n      ex: new RegExp('_ctx.' + arg.name + '(\\\\W)(?!' + allMacros + ')', 'g'),\n      re: '_ctx.' + ctx + '.' + arg.name + '$1'\n    }\n  })\n\n  // Replace all occurrences of all macros in this file with\n  // proper namespaced definitions and calls\n  utils.each(args, function (arg) {\n    var c = arg.compiled\n    utils.each(replacements, function (re) {\n      c = c.replace(re.ex, re.re)\n    })\n    out += c\n  })\n\n  return out\n}\n\nexports.parse = function (str, line, parser, types, stack, opts, swig) {\n  var compiler = __webpack_require__(/*! ../parser */ \"../node_modules/swig-templates/lib/parser.js\").compile\n  var parseOpts = { resolveFrom: opts.filename }\n  var compileOpts = utils.extend({}, opts, parseOpts)\n  var tokens\n  var ctx\n\n  parser.on(types.STRING, function (token) {\n    var self = this\n    if (!tokens) {\n      tokens = swig.parseFile(\n        token.match.replace(/^(\"|')|(\"|')$/g, ''),\n        parseOpts\n      ).tokens\n      utils.each(tokens, function (token) {\n        var out = ''\n        var macroName\n        if (!token || token.name !== 'macro' || !token.compile) {\n          return\n        }\n        macroName = token.args[0]\n        out +=\n          token.compile(compiler, token.args, token.content, [], compileOpts) +\n          '\\n'\n        self.out.push({ compiled: out, name: macroName })\n      })\n      return\n    }\n\n    throw new Error(\n      'Unexpected string ' + token.match + ' on line ' + line + '.'\n    )\n  })\n\n  parser.on(types.VAR, function (token) {\n    var self = this\n    if (!tokens || ctx) {\n      throw new Error(\n        'Unexpected variable \"' + token.match + '\" on line ' + line + '.'\n      )\n    }\n\n    if (token.match === 'as') {\n      return\n    }\n\n    ctx = token.match\n    self.out.push(ctx)\n    return false\n  })\n\n  return true\n}\n\nexports.block = true\n\n\n//# sourceURL=webpack:///../node_modules/swig-templates/lib/tags/import.js?");

/***/ }),

/***/ "../node_modules/swig-templates/lib/tags/include.js":
/*!**********************************************************!*\
  !*** ../node_modules/swig-templates/lib/tags/include.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var ignore = 'ignore'\nvar missing = 'missing'\nvar only = 'only'\n\n/**\n * Includes a template partial in place. The template is rendered within the current locals variable context.\n *\n * @alias include\n *\n * @example\n * // food = 'burritos';\n * // drink = 'lemonade';\n * {% include \"./partial.html\" %}\n * // => I like burritos and lemonade.\n *\n * @example\n * // my_obj = { food: 'tacos', drink: 'horchata' };\n * {% include \"./partial.html\" with my_obj only %}\n * // => I like tacos and horchata.\n *\n * @example\n * {% include \"/this/file/does/not/exist\" ignore missing %}\n * // => (Nothing! empty string)\n *\n * @param {string|var}  file      The path, relative to the template root, to render into the current context.\n * @param {literal}     [with]    Literally, \"with\".\n * @param {object}      [context] Local variable key-value object context to provide to the included file.\n * @param {literal}     [only]    Restricts to <strong>only</strong> passing the <code>with context</code> as local variables–the included template will not be aware of any other local variables in the parent template. For best performance, usage of this option is recommended if possible.\n * @param {literal}     [ignore missing] Will output empty string if not found instead of throwing an error.\n */\nexports.compile = function (compiler, args) {\n  var file = args.shift()\n  var onlyIdx = args.indexOf(only)\n  var onlyCtx = onlyIdx !== -1 ? args.splice(onlyIdx, 1) : false\n  var parentFile = (args.pop() || '').replace(/\\\\/g, '\\\\\\\\')\n  var ignore = args[args.length - 1] === missing ? args.pop() : false\n  var w = args.join('')\n\n  return (\n    (ignore ? '  try {\\n' : '') +\n    '_output += _swig.compileFile(' +\n    file +\n    ', {' +\n    'resolveFrom: \"' +\n    parentFile +\n    '\"' +\n    '})(' +\n    (onlyCtx && w ? w : !w ? '_ctx' : '_utils.extend({}, _ctx, ' + w + ')') +\n    ');\\n' +\n    (ignore ? '} catch (e) {}\\n' : '')\n  )\n}\n\nexports.parse = function (str, line, parser, types, stack, opts) {\n  var file, w\n  parser.on(types.STRING, function (token) {\n    if (!file) {\n      file = token.match\n      this.out.push(file)\n      return\n    }\n\n    return true\n  })\n\n  parser.on(types.VAR, function (token) {\n    if (!file) {\n      file = token.match\n      return true\n    }\n\n    if (!w && token.match === 'with') {\n      w = true\n      return\n    }\n\n    if (w && token.match === only && this.prevToken.match !== 'with') {\n      this.out.push(token.match)\n      return\n    }\n\n    if (token.match === ignore) {\n      return false\n    }\n\n    if (token.match === missing) {\n      if (this.prevToken.match !== ignore) {\n        throw new Error(\n          'Unexpected token \"' + missing + '\" on line ' + line + '.'\n        )\n      }\n      this.out.push(token.match)\n      return false\n    }\n\n    if (this.prevToken.match === ignore) {\n      throw new Error(\n        'Expected \"' +\n          missing +\n          '\" on line ' +\n          line +\n          ' but found \"' +\n          token.match +\n          '\".'\n      )\n    }\n\n    return true\n  })\n\n  parser.on('end', function () {\n    this.out.push(opts.filename || null)\n  })\n\n  return true\n}\n\n\n//# sourceURL=webpack:///../node_modules/swig-templates/lib/tags/include.js?");

/***/ }),

/***/ "../node_modules/swig-templates/lib/tags/index.js":
/*!********************************************************!*\
  !*** ../node_modules/swig-templates/lib/tags/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports.autoescape = __webpack_require__(/*! ./autoescape */ \"../node_modules/swig-templates/lib/tags/autoescape.js\")\nexports.block = __webpack_require__(/*! ./block */ \"../node_modules/swig-templates/lib/tags/block.js\")\nexports['else'] = __webpack_require__(/*! ./else */ \"../node_modules/swig-templates/lib/tags/else.js\")\nexports.elseif = __webpack_require__(/*! ./elseif */ \"../node_modules/swig-templates/lib/tags/elseif.js\")\nexports.elif = exports.elseif\nexports['extends'] = __webpack_require__(/*! ./extends */ \"../node_modules/swig-templates/lib/tags/extends.js\")\nexports.filter = __webpack_require__(/*! ./filter */ \"../node_modules/swig-templates/lib/tags/filter.js\")\nexports['for'] = __webpack_require__(/*! ./for */ \"../node_modules/swig-templates/lib/tags/for.js\")\nexports['if'] = __webpack_require__(/*! ./if */ \"../node_modules/swig-templates/lib/tags/if.js\")\nexports['import'] = __webpack_require__(/*! ./import */ \"../node_modules/swig-templates/lib/tags/import.js\")\nexports.include = __webpack_require__(/*! ./include */ \"../node_modules/swig-templates/lib/tags/include.js\")\nexports.macro = __webpack_require__(/*! ./macro */ \"../node_modules/swig-templates/lib/tags/macro.js\")\nexports.parent = __webpack_require__(/*! ./parent */ \"../node_modules/swig-templates/lib/tags/parent.js\")\nexports.raw = __webpack_require__(/*! ./raw */ \"../node_modules/swig-templates/lib/tags/raw.js\")\nexports.set = __webpack_require__(/*! ./set */ \"../node_modules/swig-templates/lib/tags/set.js\")\nexports.spaceless = __webpack_require__(/*! ./spaceless */ \"../node_modules/swig-templates/lib/tags/spaceless.js\")\n\n\n//# sourceURL=webpack:///../node_modules/swig-templates/lib/tags/index.js?");

/***/ }),

/***/ "../node_modules/swig-templates/lib/tags/macro.js":
/*!********************************************************!*\
  !*** ../node_modules/swig-templates/lib/tags/macro.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Create custom, reusable snippets within your templates.\n * Can be imported from one template to another using the <a href=\"#import\"><code data-language=\"swig\">{% import ... %}</code></a> tag.\n *\n * @alias macro\n *\n * @example\n * {% macro input(type, name, id, label, value, error) %}\n *   <label for=\"{{ name }}\">{{ label }}</label>\n *   <input type=\"{{ type }}\" name=\"{{ name }}\" id=\"{{ id }}\" value=\"{{ value }}\"{% if error %} class=\"error\"{% endif %}>\n * {% endmacro %}\n *\n * {{ input(\"text\", \"fname\", \"fname\", \"First Name\", fname.value, fname.errors) }}\n * // => <label for=\"fname\">First Name</label>\n * //    <input type=\"text\" name=\"fname\" id=\"fname\" value=\"\">\n *\n * @param {...arguments} arguments  User-defined arguments.\n */\nexports.compile = function (\n  compiler,\n  args,\n  content,\n  parents,\n  options,\n  blockName\n) {\n  var fnName = args.shift()\n\n  return (\n    '_ctx.' +\n    fnName +\n    ' = function (' +\n    args.join('') +\n    ') {\\n' +\n    '  var _output = \"\",\\n' +\n    '    __ctx = _utils.extend({}, _ctx);\\n' +\n    '  _utils.each(_ctx, function (v, k) {\\n' +\n    '    if ([\"' +\n    args.join('\",\"') +\n    '\"].indexOf(k) !== -1) { delete _ctx[k]; }\\n' +\n    '  });\\n' +\n    compiler(content, parents, options, blockName) +\n    '\\n' +\n    ' _ctx = _utils.extend(_ctx, __ctx);\\n' +\n    '  return _output;\\n' +\n    '};\\n' +\n    '_ctx.' +\n    fnName +\n    '.safe = true;\\n'\n  )\n}\n\nexports.parse = function (str, line, parser, types) {\n  var name\n\n  parser.on(types.VAR, function (token) {\n    if (token.match.indexOf('.') !== -1) {\n      throw new Error(\n        'Unexpected dot in macro argument \"' +\n          token.match +\n          '\" on line ' +\n          line +\n          '.'\n      )\n    }\n    this.out.push(token.match)\n  })\n\n  parser.on(types.FUNCTION, function (token) {\n    if (!name) {\n      name = token.match\n      this.out.push(name)\n      this.state.push(types.FUNCTION)\n    }\n  })\n\n  parser.on(types.FUNCTIONEMPTY, function (token) {\n    if (!name) {\n      name = token.match\n      this.out.push(name)\n    }\n  })\n\n  parser.on(types.PARENCLOSE, function () {\n    if (this.isLast) {\n      return\n    }\n    throw new Error('Unexpected parenthesis close on line ' + line + '.')\n  })\n\n  parser.on(types.COMMA, function () {\n    return true\n  })\n\n  parser.on('*', function () {})\n\n  return true\n}\n\nexports.ends = true\nexports.block = true\n\n\n//# sourceURL=webpack:///../node_modules/swig-templates/lib/tags/macro.js?");

/***/ }),

/***/ "../node_modules/swig-templates/lib/tags/parent.js":
/*!*********************************************************!*\
  !*** ../node_modules/swig-templates/lib/tags/parent.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Inject the content from the parent template's block of the same name into the current block.\n *\n * See <a href=\"#inheritance\">Template Inheritance</a> for more information.\n *\n * @alias parent\n *\n * @example\n * {% extends \"./foo.html\" %}\n * {% block content %}\n *   My content.\n *   {% parent %}\n * {% endblock %}\n *\n */\nexports.compile = function (\n  compiler,\n  args,\n  content,\n  parents,\n  options,\n  blockName\n) {\n  if (!parents || !parents.length) {\n    return ''\n  }\n\n  var parentFile = args[0]\n  var breaker = true\n  var l = parents.length\n  var i = 0\n  var parent\n  var block\n\n  for (i; i < l; i += 1) {\n    parent = parents[i]\n    if (!parent.blocks || !parent.blocks.hasOwnProperty(blockName)) {\n      continue\n    }\n    if (breaker && parentFile !== parent.name) {\n      block = parent.blocks[blockName]\n      return (\n        block.compile(\n          compiler,\n          [blockName],\n          block.content,\n          parents.slice(i + 1),\n          options\n        ) + '\\n'\n      )\n    }\n  }\n}\n\nexports.parse = function (str, line, parser, types, stack, opts) {\n  parser.on('*', function (token) {\n    throw new Error(\n      'Unexpected argument \"' + token.match + '\" on line ' + line + '.'\n    )\n  })\n\n  parser.on('end', function () {\n    this.out.push(opts.filename)\n  })\n\n  return true\n}\n\n\n//# sourceURL=webpack:///../node_modules/swig-templates/lib/tags/parent.js?");

/***/ }),

/***/ "../node_modules/swig-templates/lib/tags/raw.js":
/*!******************************************************!*\
  !*** ../node_modules/swig-templates/lib/tags/raw.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Magic tag, hardcoded into parser\n\n/**\n * Forces the content to not be auto-escaped. All swig instructions will be ignored and the content will be rendered exactly as it was given.\n *\n * @alias raw\n *\n * @example\n * // foobar = '<p>'\n * {% raw %}{{ foobar }}{% endraw %}\n * // => {{ foobar }}\n *\n */\nexports.compile = function (\n  compiler,\n  args,\n  content,\n  parents,\n  options,\n  blockName\n) {\n  return compiler(content, parents, options, blockName)\n}\nexports.parse = function (str, line, parser) {\n  parser.on('*', function (token) {\n    throw new Error(\n      'Unexpected token \"' + token.match + '\" in raw tag on line ' + line + '.'\n    )\n  })\n  return true\n}\nexports.ends = true\n\n\n//# sourceURL=webpack:///../node_modules/swig-templates/lib/tags/raw.js?");

/***/ }),

/***/ "../node_modules/swig-templates/lib/tags/set.js":
/*!******************************************************!*\
  !*** ../node_modules/swig-templates/lib/tags/set.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Set a variable for re-use in the current context. This will over-write any value already set to the context for the given <var>varname</var>.\n *\n * @alias set\n *\n * @example\n * {% set foo = \"anything!\" %}\n * {{ foo }}\n * // => anything!\n *\n * @example\n * // index = 2;\n * {% set bar = 1 %}\n * {% set bar += index|default(3) %}\n * // => 3\n *\n * @example\n * // foods = {};\n * // food = 'chili';\n * {% set foods[food] = \"con queso\" %}\n * {{ foods.chili }}\n * // => con queso\n *\n * @example\n * // foods = { chili: 'chili con queso' }\n * {% set foods.chili = \"guatamalan insanity pepper\" %}\n * {{ foods.chili }}\n * // => guatamalan insanity pepper\n *\n * @param {literal} varname   The variable name to assign the value to.\n * @param {literal} assignement   Any valid JavaScript assignement. <code data-language=\"js\">=, +=, *=, /=, -=</code>\n * @param {*}   value     Valid variable output.\n */\nexports.compile = function (compiler, args) {\n  return args.join(' ') + ';\\n'\n}\n\nexports.parse = function (str, line, parser, types) {\n  var nameSet = ''\n  var propertyName\n\n  parser.on(types.VAR, function (token) {\n    if (propertyName) {\n      // Tell the parser where to find the variable\n      propertyName += '_ctx.' + token.match\n      return\n    }\n\n    if (!parser.out.length) {\n      nameSet += token.match\n      return\n    }\n\n    return true\n  })\n\n  parser.on(types.BRACKETOPEN, function (token) {\n    if (!propertyName && !this.out.length) {\n      propertyName = token.match\n      return\n    }\n\n    return true\n  })\n\n  parser.on(types.STRING, function (token) {\n    if (propertyName && !this.out.length) {\n      propertyName += token.match\n      return\n    }\n\n    return true\n  })\n\n  parser.on(types.BRACKETCLOSE, function (token) {\n    if (propertyName && !this.out.length) {\n      nameSet += propertyName + token.match\n      propertyName = undefined\n      return\n    }\n\n    return true\n  })\n\n  parser.on(types.DOTKEY, function (token) {\n    if (!propertyName && !nameSet) {\n      return true\n    }\n    nameSet += '.' + token.match\n  })\n\n  parser.on(types.ASSIGNMENT, function (token) {\n    if (this.out.length || !nameSet) {\n      throw new Error(\n        'Unexpected assignment \"' + token.match + '\" on line ' + line + '.'\n      )\n    }\n\n    this.out.push(\n      // Prevent the set from spilling into global scope\n      '_ctx.' + nameSet\n    )\n    this.out.push(token.match)\n    this.filterApplyIdx.push(this.out.length)\n  })\n\n  return true\n}\n\nexports.block = true\n\n\n//# sourceURL=webpack:///../node_modules/swig-templates/lib/tags/set.js?");

/***/ }),

/***/ "../node_modules/swig-templates/lib/tags/spaceless.js":
/*!************************************************************!*\
  !*** ../node_modules/swig-templates/lib/tags/spaceless.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Attempts to remove whitespace between HTML tags. Use at your own risk.\n *\n * @alias spaceless\n *\n * @example\n * {% spaceless %}\n *   {% for num in foo %}\n *   <li>{{ loop.index }}</li>\n *   {% endfor %}\n * {% endspaceless %}\n * // => <li>1</li><li>2</li><li>3</li>\n *\n */\nexports.compile = function (\n  compiler,\n  args,\n  content,\n  parents,\n  options,\n  blockName\n) {\n  var out = compiler(content, parents, options, blockName)\n  out +=\n    '_output = _output.replace(/^\\\\s+/, \"\")\\n' +\n    '  .replace(/>\\\\s+</g, \"><\")\\n' +\n    '  .replace(/\\\\s+$/, \"\");\\n'\n\n  return out\n}\n\nexports.parse = function (str, line, parser) {\n  parser.on('*', function (token) {\n    throw new Error(\n      'Unexpected token \"' + token.match + '\" on line ' + line + '.'\n    )\n  })\n\n  return true\n}\n\nexports.ends = true\n\n\n//# sourceURL=webpack:///../node_modules/swig-templates/lib/tags/spaceless.js?");

/***/ }),

/***/ "../node_modules/swig-templates/lib/utils.js":
/*!***************************************************!*\
  !*** ../node_modules/swig-templates/lib/utils.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var isArray\n\n/**\n * Strip leading and trailing whitespace from a string.\n * @param  {string} input\n * @return {string}       Stripped input.\n */\nexports.strip = function (input) {\n  return input.replace(/^\\s+|\\s+$/g, '')\n}\n\n/**\n * Test if a string starts with a given prefix.\n * @param  {string} str    String to test against.\n * @param  {string} prefix Prefix to check for.\n * @return {boolean}\n */\nexports.startsWith = function (str, prefix) {\n  return str.indexOf(prefix) === 0\n}\n\n/**\n * Test if a string ends with a given suffix.\n * @param  {string} str    String to test against.\n * @param  {string} suffix Suffix to check for.\n * @return {boolean}\n */\nexports.endsWith = function (str, suffix) {\n  return str.indexOf(suffix, str.length - suffix.length) !== -1\n}\n\n/**\n * Iterate over an array or object.\n * @param  {array|object} obj Enumerable object.\n * @param  {Function}     fn  Callback function executed for each item.\n * @return {array|object}     The original input object.\n */\nexports.each = function (obj, fn) {\n  var i, l\n\n  if (isArray(obj)) {\n    i = 0\n    l = obj.length\n    for (i; i < l; i += 1) {\n      if (fn(obj[i], i, obj) === false) {\n        break\n      }\n    }\n  } else {\n    for (i in obj) {\n      if (obj.hasOwnProperty(i)) {\n        if (fn(obj[i], i, obj) === false) {\n          break\n        }\n      }\n    }\n  }\n\n  return obj\n}\n\n/**\n * Test if an object is an Array.\n * @param {object} obj\n * @return {boolean}\n */\nexports.isArray = isArray = Array.hasOwnProperty('isArray')\n  ? Array.isArray\n  : function (obj) {\n    return obj\n      ? typeof obj === 'object' &&\n            Object.prototype.toString.call(obj).indexOf() !== -1\n      : false\n  }\n\n/**\n * Test if an item in an enumerable matches your conditions.\n * @param  {array|object}   obj   Enumerable object.\n * @param  {Function}       fn    Executed for each item. Return true if your condition is met.\n * @return {boolean}\n */\nexports.some = function (obj, fn) {\n  var i = 0\n  var result\n  var l\n  if (isArray(obj)) {\n    l = obj.length\n\n    for (i; i < l; i += 1) {\n      result = fn(obj[i], i, obj)\n      if (result) {\n        break\n      }\n    }\n  } else {\n    exports.each(obj, function (value, index) {\n      result = fn(value, index, obj)\n      return !result\n    })\n  }\n  return !!result\n}\n\n/**\n * Return a new enumerable, mapped by a given iteration function.\n * @param  {object}   obj Enumerable object.\n * @param  {Function} fn  Executed for each item. Return the item to replace the original item with.\n * @return {object}       New mapped object.\n */\nexports.map = function (obj, fn) {\n  var i = 0\n  var result = []\n  var l\n\n  if (isArray(obj)) {\n    l = obj.length\n    for (i; i < l; i += 1) {\n      result[i] = fn(obj[i], i)\n    }\n  } else {\n    for (i in obj) {\n      if (obj.hasOwnProperty(i)) {\n        result[i] = fn(obj[i], i)\n      }\n    }\n  }\n  return result\n}\n\n/**\n * Copy all of the properties in the source objects over to the destination object, and return the destination object. It's in-order, so the last source will override properties of the same name in previous arguments.\n * @param {...object} arguments\n * @return {object}\n */\nexports.extend = function () {\n  var args = arguments\n  var target = args[0]\n  var objs = args.length > 1 ? Array.prototype.slice.call(args, 1) : []\n  var i = 0\n  var l = objs.length\n  var key\n  var obj\n\n  for (i; i < l; i += 1) {\n    obj = objs[i] || {}\n    for (key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        target[key] = obj[key]\n      }\n    }\n  }\n  return target\n}\n\n/**\n * Get all of the keys on an object.\n * @param  {object} obj\n * @return {array}\n */\nexports.keys = function (obj) {\n  if (!obj) {\n    return []\n  }\n\n  if (Object.keys) {\n    return Object.keys(obj)\n  }\n\n  return exports.map(obj, function (v, k) {\n    return k\n  })\n}\n\n/**\n * Throw an error with possible line number and source file.\n * @param  {string} message Error message\n * @param  {number} [line]  Line number in template.\n * @param  {string} [file]  Template file the error occured in.\n * @throws {Error} No seriously, the point is to throw an error.\n */\nexports.throwError = function (message, line, file) {\n  if (line) {\n    message += ' on line ' + line\n  }\n  if (file) {\n    message += ' in file ' + file\n  }\n  throw new Error(message + '.')\n}\n\n\n//# sourceURL=webpack:///../node_modules/swig-templates/lib/utils.js?");

/***/ }),

/***/ "../node_modules/utils-merge/index.js":
/*!********************************************!*\
  !*** ../node_modules/utils-merge/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Merge object b with object a.\n *\n *     var a = { foo: 'bar' }\n *       , b = { bar: 'baz' };\n *\n *     merge(a, b);\n *     // => { foo: 'bar', bar: 'baz' }\n *\n * @param {Object} a\n * @param {Object} b\n * @return {Object}\n * @api public\n */\n\nexports = module.exports = function(a, b){\n  if (a && b) {\n    for (var key in b) {\n      a[key] = b[key];\n    }\n  }\n  return a;\n};\n\n\n//# sourceURL=webpack:///../node_modules/utils-merge/index.js?");

/***/ }),

/***/ "./dist/assets/manifest.json":
/*!***********************************!*\
  !*** ./dist/assets/manifest.json ***!
  \***********************************/
/*! exports provided: index.js, runtime.js, vendor.js, ../templates/index.html, ../templates/layout.html, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"index.js\\\":\\\"/scripts/index.bundle.js\\\",\\\"runtime.js\\\":\\\"/scripts/runtime.bundle.js\\\",\\\"vendor.js\\\":\\\"/scripts/vendor.bundle.js\\\",\\\"../templates/index.html\\\":\\\"/../templates/index.html\\\",\\\"../templates/layout.html\\\":\\\"/../templates/layout.html\\\"}\");\n\n//# sourceURL=webpack:///./dist/assets/manifest.json?");

/***/ }),

/***/ "./src/server/app.tsx":
/*!****************************!*\
  !*** ./src/server/app.tsx ***!
  \****************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! config */ \"config\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var koa__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! koa */ \"koa\");\n/* harmony import */ var koa__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(koa__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var koa_favicon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! koa-favicon */ \"koa-favicon\");\n/* harmony import */ var koa_favicon__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(koa_favicon__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var koa_static__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! koa-static */ \"koa-static\");\n/* harmony import */ var koa_static__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(koa_static__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var koa_router__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! koa-router */ \"koa-router\");\n/* harmony import */ var koa_router__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(koa_router__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var koa_swig__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! koa-swig */ \"../node_modules/koa-swig/index.js\");\n/* harmony import */ var koa_swig__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(koa_swig__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var co__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! co */ \"co\");\n/* harmony import */ var co__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(co__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _server_utils_bigpipe__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @/server/utils/bigpipe */ \"./src/server/utils/bigpipe.ts\");\n/* harmony import */ var isomorphic_unfetch__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! isomorphic-unfetch */ \"isomorphic-unfetch\");\n/* harmony import */ var isomorphic_unfetch__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(isomorphic_unfetch__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var react_dom_server__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! react-dom/server */ \"react-dom/server\");\n/* harmony import */ var react_dom_server__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(react_dom_server__WEBPACK_IMPORTED_MODULE_12__);\n/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! react-router-dom */ \"react-router-dom\");\n/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(react_router_dom__WEBPACK_IMPORTED_MODULE_13__);\n/* harmony import */ var react_router_config__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! react-router-config */ \"react-router-config\");\n/* harmony import */ var react_router_config__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(react_router_config__WEBPACK_IMPORTED_MODULE_14__);\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! react-redux */ \"react-redux\");\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(react_redux__WEBPACK_IMPORTED_MODULE_15__);\n/* harmony import */ var _shared_store__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @/shared/store */ \"./src/shared/store/index.ts\");\n/* harmony import */ var _shared_App__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @/shared/App */ \"./src/shared/App.tsx\");\n/* harmony import */ var _shared_routes__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @/shared/routes */ \"./src/shared/routes.ts\");\n/* harmony import */ var _dist_assets_manifest_json__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @dist/assets/manifest.json */ \"./dist/assets/manifest.json\");\nvar _dist_assets_manifest_json__WEBPACK_IMPORTED_MODULE_19___namespace = /*#__PURE__*/__webpack_require__.t(/*! @dist/assets/manifest.json */ \"./dist/assets/manifest.json\", 1);\n/**\n * @fileoverview node server entry\n * @author liuduan\n * @Date 2020-06-26 11:57:12\n * @LastEditTime 2020-06-27 22:09:10\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n // 抓取全局异常\n\nprocess.on('uncaughtException', err => {\n  console.log(err, 'caught_by_uncaughtException');\n  throw err;\n}); // 抓取异步异常\n\nprocess.on('unhandledRejection', function (err, p) {\n  console.log(err, 'caught_by_unhandledRejection');\n});\nconst PORT = config__WEBPACK_IMPORTED_MODULE_2___default.a.get('port');\nconst app = new koa__WEBPACK_IMPORTED_MODULE_3___default.a();\nconst router = new koa_router__WEBPACK_IMPORTED_MODULE_6___default.a();\napp.use(koa_favicon__WEBPACK_IMPORTED_MODULE_4___default()('favicon.ico'));\napp.use(koa_static__WEBPACK_IMPORTED_MODULE_5___default()('dist/assets'));\napp.context.render = co__WEBPACK_IMPORTED_MODULE_8___default.a.wrap(new koa_swig__WEBPACK_IMPORTED_MODULE_7___default.a({\n  root: path__WEBPACK_IMPORTED_MODULE_0___default.a.resolve('dist/templates'),\n  autoescape: false,\n  cache:  true ? false : undefined,\n  ext: 'html',\n  writeBody: false\n}));\n\nfunction getScriptsAssets(pagename) {\n  if (!_dist_assets_manifest_json__WEBPACK_IMPORTED_MODULE_19__) {\n    return [];\n  }\n\n  const fileList = ['runtime', 'vendor', 'commons', pagename];\n  const scripts = [];\n\n  for (const filename of fileList) {\n    let filePath;\n\n    if (filePath = _dist_assets_manifest_json__WEBPACK_IMPORTED_MODULE_19__[`${filename}.js`]) {\n      scripts.push(filePath);\n    }\n  }\n\n  return scripts;\n}\n\nfunction outputScripts(scripts) {\n  return scripts.map(src => `<script type=\"text/javascript\" src=\"${src}\"></script>`).join('\\n');\n}\n\nasync function updateReduxStore(ctx, store) {\n  const branch = Object(react_router_config__WEBPACK_IMPORTED_MODULE_14__[\"matchRoutes\"])(_shared_routes__WEBPACK_IMPORTED_MODULE_18__[\"default\"], ctx.url);\n  const promises = branch.map(({\n    route,\n    match\n  }) => {\n    return route.loadData ? route.loadData(store) : Promise.resolve(null);\n  });\n  await Promise.all(promises);\n  return `<script type=\"text/javascript\">window.__SSR_REDUX_STOR__=${JSON.stringify(store.getState())};</script>`;\n}\n\nasync function outputMarkup(ctx, store) {\n  return react_dom_server__WEBPACK_IMPORTED_MODULE_12___default.a.renderToString( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_11___default.a.createElement(react_redux__WEBPACK_IMPORTED_MODULE_15__[\"Provider\"], {\n    store: store\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_11___default.a.createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_13__[\"StaticRouter\"], {\n    location: ctx.url,\n    context: ctx\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_11___default.a.createElement(_shared_App__WEBPACK_IMPORTED_MODULE_17__[\"default\"], null))));\n}\n\nasync function getTemplatePathByPagename(pagename) {\n  return new Promise((resolve, reject) => {\n    let templatePath = path__WEBPACK_IMPORTED_MODULE_0___default.a.resolve(`src/client/template/${pagename}.html`);\n    fs__WEBPACK_IMPORTED_MODULE_1___default.a.stat(templatePath, (err, stat) => {\n      if (stat && stat.isFile()) {\n        resolve(templatePath);\n      } else {\n        resolve(path__WEBPACK_IMPORTED_MODULE_0___default.a.resolve('src/client/template/index.html'));\n      }\n    });\n  });\n}\n\nasync function renderTemplate(templatePath, options) {}\n\napp.use(async (ctx, next) => {\n  try {\n    await next();\n  } catch (error) {\n    ctx.body = error;\n  }\n});\nrouter.get('/api/about', (ctx, next) => {\n  ctx.body = {\n    code: 0,\n    msg: 'success',\n    data: '我是api接口后端返回的about数据内容'\n  };\n}).get(['/', '/about'], async (ctx, next) => {\n  const pagename = 'index';\n  const store = Object(_shared_store__WEBPACK_IMPORTED_MODULE_16__[\"createServerStore\"])();\n  const scripts = getScriptsAssets(pagename);\n  await updateReduxStore(ctx, store); // 注意：这里需要先处理完store在markup\n\n  const markup = await outputMarkup(ctx, store); // @ts-ignore\n\n  const html = await ctx.render(pagename, {\n    title: 'react-ssr-demo',\n    markup,\n    reduxStore: JSON.stringify(store.getState()),\n    scripts\n  });\n  await Object(_server_utils_bigpipe__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(ctx, html);\n});\napp.use(router.routes()).use(router.allowedMethods());\napp.listen(PORT, () => {\n  console.log(`🍻🍻 node server is running on http://localhost/${PORT}`);\n}).on('clientError', (err, socket) => {\n  // handleErr(err, 'caught_by_koa_on_client_error');\n  socket.end('HTTP/1.1 400 Bad Request Request invalid\\r\\n\\r\\n');\n});\n\n//# sourceURL=webpack:///./src/server/app.tsx?");

/***/ }),

/***/ "./src/server/utils/bigpipe.ts":
/*!*************************************!*\
  !*** ./src/server/utils/bigpipe.ts ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return bigpipe; });\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_0__);\n/**\n * @fileoverview bigpipe ssr big html file\n * @author liuduan\n * @Date 2020-06-26 17:57:30\n * @LastEditTime 2020-06-26 18:25:31\n */\n\n/**\n * @description 响应大文件html，分块输出给浏览器方式\n * @param {ctx} ctx\n * @param {string} html\n * @return {promise}\n */\n\nfunction bigpipe(ctx, html) {\n  return new Promise((resolve, reject) => {\n    const rs = new stream__WEBPACK_IMPORTED_MODULE_0__[\"Readable\"]();\n    rs.push(html);\n    rs.push(null);\n    ctx.status = 200;\n    ctx.type = 'text/html';\n    rs.on('error', reject);\n    rs.on('end', resolve);\n    rs.pipe(ctx.res);\n  });\n}\n\n//# sourceURL=webpack:///./src/server/utils/bigpipe.ts?");

/***/ }),

/***/ "./src/shared/App.tsx":
/*!****************************!*\
  !*** ./src/shared/App.tsx ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-router-dom */ \"react-router-dom\");\n/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_router_dom__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_router_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-router-config */ \"react-router-config\");\n/* harmony import */ var react_router_config__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_router_config__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _routes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./routes */ \"./src/shared/routes.ts\");\n/**\n * @fileoverview App Component\n * @author liuduan\n * @Date 2020-06-26 11:55:59\n * @LastEditTime 2020-06-27 10:17:31\n */\n\n\n\n\n\nconst App = () => {\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"div\", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"ul\", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"li\", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_1__[\"Link\"], {\n    to: \"/\"\n  }, \"Home\")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"li\", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_1__[\"Link\"], {\n    to: \"/about\"\n  }, \"About\"))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"hr\", null), Object(react_router_config__WEBPACK_IMPORTED_MODULE_2__[\"renderRoutes\"])(_routes__WEBPACK_IMPORTED_MODULE_3__[\"default\"]));\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (App);\n\n//# sourceURL=webpack:///./src/shared/App.tsx?");

/***/ }),

/***/ "./src/shared/components/About.tsx":
/*!*****************************************!*\
  !*** ./src/shared/components/About.tsx ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-redux */ \"react-redux\");\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_redux__WEBPACK_IMPORTED_MODULE_1__);\n/**\n * @fileoverview \n * @author liuduan\n * @Date 2020-06-25 11:21:44\n * @LastEditTime 2020-06-26 17:06:53\n */\n\n\n\nfunction About(props) {\n  Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(() => {\n    if (!props.aboutData) {\n      console.log('执行init');\n      init();\n    }\n  }, []);\n\n  function init() {\n    fetch('http://localhost:6027/api/about').then(res => res.json()).then(res => {\n      props.updateAboutData(res.data);\n      return res;\n    }).catch(e => e);\n  }\n\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"div\", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"h2\", null, \"About\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"p\", null, props.aboutData));\n}\n\nconst updateAboutData = payload => {\n  return {\n    type: 'UPDATE_ABOUT_DATA',\n    payload\n  };\n};\n\nAbout.loadData = store => {\n  return fetch('http://localhost:6027/api/about').then(res => res.json()).then(res => {\n    store.dispatch(updateAboutData(res.data));\n    return res;\n  }).catch(e => e);\n};\n\nfunction mapStateToProps(state) {\n  return {\n    aboutData: state.aboutData\n  };\n}\n\nfunction mapDispatchToProps(dispatch) {\n  return {\n    updateAboutData: payload => {\n      dispatch(updateAboutData(payload));\n    }\n  };\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Object(react_redux__WEBPACK_IMPORTED_MODULE_1__[\"connect\"])(mapStateToProps, mapDispatchToProps)(About));\n\n//# sourceURL=webpack:///./src/shared/components/About.tsx?");

/***/ }),

/***/ "./src/shared/components/CheckboxGroup.tsx":
/*!*************************************************!*\
  !*** ./src/shared/components/CheckboxGroup.tsx ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n/**\n * @fileoverview \n * @author liuduan\n * @Date 2020-06-26 22:33:23\n * @LastEditTime 2020-06-26 23:33:00\n */\n\n\nclass CheckboxGroup extends react__WEBPACK_IMPORTED_MODULE_0___default.a.PureComponent {\n  constructor(props) {\n    super(props);\n    this.handleChangeAll = this.handleChangeAll.bind(this);\n    this.handleChange = this.handleChange.bind(this);\n  }\n\n  handleChangeAll(e) {\n    const {\n      list,\n      onChange\n    } = this.props;\n    const {\n      checked\n    } = e.target;\n    let newSelected = [];\n\n    if (checked) {\n      newSelected = list.map(({\n        id\n      }) => id);\n    }\n\n    onChange(newSelected);\n  }\n\n  handleChange(e) {\n    const {\n      selected,\n      onChange\n    } = this.props;\n    const {\n      checked,\n      value\n    } = e.target;\n    let newSelected = [];\n\n    if (checked) {\n      newSelected = [...selected, value];\n    } else {\n      newSelected = selected.filter(s => s !== value);\n    }\n\n    onChange(newSelected);\n  }\n\n  render() {\n    const {\n      selected,\n      list\n    } = this.props;\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Checkbox, {\n      value: \"\\u5168\\u9009\",\n      id: \"all\",\n      checked: selected.length === list.length,\n      onChange: this.handleChangeAll\n    }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"hr\", null), list.map(({\n      id,\n      value\n    }) => {\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Checkbox, {\n        key: id,\n        value: value,\n        id: id,\n        checked: selected.includes(id),\n        onChange: this.handleChange\n      });\n    }));\n  }\n\n}\n\nconst CheckboxGroupHooks = ({\n  selected,\n  list,\n  onChange\n}) => {\n  function handleChangeAll(e) {\n    const {\n      checked\n    } = e.target;\n    let newSelected = [];\n\n    if (checked) {\n      newSelected = list.map(({\n        id\n      }) => id);\n    }\n\n    onChange(newSelected);\n  }\n\n  const handleChange = e => {\n    const {\n      checked,\n      value\n    } = e.target;\n    let newSelected = [];\n\n    if (checked) {\n      newSelected = [...selected, value];\n    } else {\n      newSelected = selected.filter(s => s !== value);\n    }\n\n    onChange(newSelected);\n  };\n\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Checkbox, {\n    value: \"\\u5168\\u9009\",\n    id: \"all\",\n    checked: selected.length === list.length,\n    onChange: handleChangeAll\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"hr\", null), list.map(({\n    id,\n    value\n  }) => {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Checkbox, {\n      key: id,\n      value: value,\n      id: id,\n      checked: selected.includes(id),\n      onChange: handleChange\n    });\n  }));\n};\n\nconst Checkbox = /*#__PURE__*/Object(react__WEBPACK_IMPORTED_MODULE_0__[\"memo\"])(({\n  id,\n  value,\n  checked,\n  ...otherProps\n}) => {\n  console.log('Checkbox render', id);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"label\", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"input\", _extends({\n    id: id,\n    type: \"checkbox\",\n    value: id,\n    checked: checked\n  }, otherProps)), value);\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (CheckboxGroup);\n\n//# sourceURL=webpack:///./src/shared/components/CheckboxGroup.tsx?");

/***/ }),

/***/ "./src/shared/components/Home.tsx":
/*!****************************************!*\
  !*** ./src/shared/components/Home.tsx ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _CheckboxGroup__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CheckboxGroup */ \"./src/shared/components/CheckboxGroup.tsx\");\n/* harmony import */ var _utils_request__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/request */ \"./src/shared/utils/request.ts\");\n/**\n * @fileoverview \n * @author liuduan\n * @Date 2020-06-25 11:21:44\n * @LastEditTime 2020-06-27 22:08:30\n */\n\n\n\nconst list = [{\n  id: '1',\n  value: '苹果'\n}, {\n  id: '2',\n  value: '鸡蛋'\n}, {\n  id: '3',\n  value: '鸭梨'\n}];\n\nfunction Home() {\n  const [selected, setSelected] = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(['1', '2', '3']);\n\n  function handleChange(newSelected) {\n    setSelected(newSelected);\n  }\n\n  Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(() => {\n    let urls = Array.from({\n      length: 10\n    }, (v, k) => `http://localhost:6027/api/${k}`);\n    let max = 3;\n\n    let callback = res => {\n      console.log('run callback', res);\n    }; //执行\n\n\n    Object(_utils_request__WEBPACK_IMPORTED_MODULE_2__[\"sendRequest\"])(urls, max, callback);\n  }, []);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"div\", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"h2\", null, \"Home\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_CheckboxGroup__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n    list: list,\n    onChange: handleChange,\n    selected: selected\n  }));\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Home);\n\n//# sourceURL=webpack:///./src/shared/components/Home.tsx?");

/***/ }),

/***/ "./src/shared/routes.ts":
/*!******************************!*\
  !*** ./src/shared/routes.ts ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components_Home__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/Home */ \"./src/shared/components/Home.tsx\");\n/* harmony import */ var _components_About__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/About */ \"./src/shared/components/About.tsx\");\n/**\n * @fileoverview 路由配置表\n * @author liuduan\n * @Date 2020-06-26 12:08:26\n * @LastEditTime 2020-06-26 13:54:25\n */\n\n\nconst routes = [{\n  path: '/',\n  exact: true,\n  component: _components_Home__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\n}, {\n  path: '/about',\n  component: _components_About__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  loadData: _components_About__WEBPACK_IMPORTED_MODULE_1__[\"default\"].loadData\n}];\n/* harmony default export */ __webpack_exports__[\"default\"] = (routes);\n\n//# sourceURL=webpack:///./src/shared/routes.ts?");

/***/ }),

/***/ "./src/shared/store/index.ts":
/*!***********************************!*\
  !*** ./src/shared/store/index.ts ***!
  \***********************************/
/*! exports provided: createServerStore, createClientStore */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createServerStore\", function() { return createServerStore; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createClientStore\", function() { return createClientStore; });\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! redux */ \"redux\");\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(redux__WEBPACK_IMPORTED_MODULE_0__);\n/**\n * @fileoverview redux store for client and server\n * @author liuduan\n * @Date 2020-06-26 13:54:41\n * @LastEditTime 2020-06-26 18:58:07\n */\n\nconst initialState = {};\n\nfunction reducer(preState = initialState, action) {\n  switch (action.type) {\n    case 'UPDATE_ABOUT_DATA':\n      return { ...preState,\n        aboutData: action.payload\n      };\n\n    default:\n      return preState;\n  }\n}\n\nfunction createServerStore() {\n  return Object(redux__WEBPACK_IMPORTED_MODULE_0__[\"createStore\"])(reducer);\n}\nfunction createClientStore() {\n  return Object(redux__WEBPACK_IMPORTED_MODULE_0__[\"createStore\"])(reducer, window.__SSR_REDUX_STORE__);\n}\n\n//# sourceURL=webpack:///./src/shared/store/index.ts?");

/***/ }),

/***/ "./src/shared/utils/request.ts":
/*!*************************************!*\
  !*** ./src/shared/utils/request.ts ***!
  \*************************************/
/*! exports provided: sendRequest */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sendRequest\", function() { return sendRequest; });\n/**\n * @fileoverview \n * @author liuduan\n * @Date 2020-06-27 19:36:03\n * @LastEditTime 2020-06-27 21:54:01\n */\nfunction sendRequest(urls, max, callback) {\n  let count = 0;\n  let cur = 0;\n  let l = urls.length;\n  let result = [];\n\n  if (cur === l) {\n    callback(result);\n    return;\n  }\n\n  ;\n\n  function request() {\n    if (cur >= l) {\n      return;\n    }\n\n    let url = urls[cur];\n    let point = cur++;\n\n    function handle(response) {\n      console.log(point, 'end 当前并发数为: ' + count);\n      result[point] = response;\n      count--;\n\n      if (cur < l) {\n        request();\n      } else if (count === 0) {\n        callback(result);\n      }\n    }\n\n    if (url) {\n      count++;\n      fetch(url).then(response => {\n        if (response.status >= 200 && response.status < 300) {\n          return response;\n        }\n\n        const error = new Error(response.statusText); // @ts-ignore\n\n        error.response = response;\n        throw error;\n      }).then(res => res.json()).then(handle).catch(handle);\n    }\n\n    console.log(point, 'start 当前并发数为: ' + count);\n\n    if (count < max && cur < l) {\n      request();\n    }\n  }\n\n  request();\n}\n\n//# sourceURL=webpack:///./src/shared/utils/request.ts?");

/***/ }),

/***/ "co":
/*!*********************!*\
  !*** external "co" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"co\");\n\n//# sourceURL=webpack:///external_%22co%22?");

/***/ }),

/***/ "config":
/*!*************************!*\
  !*** external "config" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"config\");\n\n//# sourceURL=webpack:///external_%22config%22?");

/***/ }),

/***/ "debug":
/*!************************!*\
  !*** external "debug" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"debug\");\n\n//# sourceURL=webpack:///external_%22debug%22?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");\n\n//# sourceURL=webpack:///external_%22fs%22?");

/***/ }),

/***/ "isomorphic-unfetch":
/*!*************************************!*\
  !*** external "isomorphic-unfetch" ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"isomorphic-unfetch\");\n\n//# sourceURL=webpack:///external_%22isomorphic-unfetch%22?");

/***/ }),

/***/ "koa":
/*!**********************!*\
  !*** external "koa" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"koa\");\n\n//# sourceURL=webpack:///external_%22koa%22?");

/***/ }),

/***/ "koa-favicon":
/*!******************************!*\
  !*** external "koa-favicon" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"koa-favicon\");\n\n//# sourceURL=webpack:///external_%22koa-favicon%22?");

/***/ }),

/***/ "koa-router":
/*!*****************************!*\
  !*** external "koa-router" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"koa-router\");\n\n//# sourceURL=webpack:///external_%22koa-router%22?");

/***/ }),

/***/ "koa-static":
/*!*****************************!*\
  !*** external "koa-static" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"koa-static\");\n\n//# sourceURL=webpack:///external_%22koa-static%22?");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"path\");\n\n//# sourceURL=webpack:///external_%22path%22?");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"react\");\n\n//# sourceURL=webpack:///external_%22react%22?");

/***/ }),

/***/ "react-dom/server":
/*!***********************************!*\
  !*** external "react-dom/server" ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"react-dom/server\");\n\n//# sourceURL=webpack:///external_%22react-dom/server%22?");

/***/ }),

/***/ "react-redux":
/*!******************************!*\
  !*** external "react-redux" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"react-redux\");\n\n//# sourceURL=webpack:///external_%22react-redux%22?");

/***/ }),

/***/ "react-router-config":
/*!**************************************!*\
  !*** external "react-router-config" ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"react-router-config\");\n\n//# sourceURL=webpack:///external_%22react-router-config%22?");

/***/ }),

/***/ "react-router-dom":
/*!***********************************!*\
  !*** external "react-router-dom" ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"react-router-dom\");\n\n//# sourceURL=webpack:///external_%22react-router-dom%22?");

/***/ }),

/***/ "redux":
/*!************************!*\
  !*** external "redux" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"redux\");\n\n//# sourceURL=webpack:///external_%22redux%22?");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"stream\");\n\n//# sourceURL=webpack:///external_%22stream%22?");

/***/ }),

/***/ "thenify":
/*!**************************!*\
  !*** external "thenify" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"thenify\");\n\n//# sourceURL=webpack:///external_%22thenify%22?");

/***/ })

/******/ });